{"mappings":"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","sources":["js/shaders/FFTOceanShader.js"],"sourcesContent":["ï»¿/**\n * Original work:\n * @author David Li / http://david.li/waves/\n *\n * Three.js version:\n * @author Aleksandr Albert / http://www.routter.co.tt\n * \n * Modified:\n * @author jbouny / https://github.com/fft-ocean\n */\n \n// Author: Aleksandr Albert\n// Website: www.routter.co.tt\n\n// Description: A deep water ocean shader set\n// based on an implementation of a Tessendorf Waves\n// originally presented by David Li ( www.david.li/waves )\n\n// The general method is to apply shaders to simulation Framebuffers\n// and then sample these framebuffers when rendering the ocean mesh\n\n// The set uses 7 shaders:\n\n// -- Simulation shaders\n// [1] ocean_sim_vertex         -> Vertex shader used to set up a 2x2 simulation plane centered at (0,0)\n// [2] ocean_subtransform       -> Fragment shader used to subtransform the mesh (generates the displacement map)\n// [3] ocean_initial_spectrum   -> Fragment shader used to set intitial wave frequency at a texel coordinate\n// [4] ocean_phase              -> Fragment shader used to set wave phase at a texel coordinate\n// [5] ocean_spectrum           -> Fragment shader used to set current wave frequency at a texel coordinate\n// [6] ocean_normal             -> Fragment shader used to set face normals at a texel coordinate\n\n// -- Rendering Shader\n// [7] ocean_main               -> Vertex and Fragment shader used to create the final render\n\n\nTHREE.ShaderLib['ocean_sim_vertex'] = {\n\tvarying: {\n\t\t\"vUV\": { type: \"v2\" }\n\t},\n\tvertexShader: [\n\t\t'varying vec2 vUV;',\n\n\t\t'void main (void) {',\n\t\t\t'vUV = position.xy * 0.5 + 0.5;',\n\t\t\t'gl_Position = vec4(position, 1.0 );',\n\t\t'}'\n\t].join('\\n')\n};\nTHREE.ShaderLib['ocean_subtransform'] = {\n\tuniforms: {\n\t\t\"u_input\": { type: \"t\", value: null },\n\t\t\"u_transformSize\": { type: \"f\", value: 512.0 },\n\t\t\"u_subtransformSize\": { type: \"f\", value: 250.0 }\n\t},\n\tvarying: {\n\t\t\"vUV\": { type: \"v2\" }\n\t},\n\tfragmentShader: [\n\t\t//GPU FFT using a Stockham formulation\n\n\t\t'const float PI = 3.14159265359;',\n\n\t\t'uniform sampler2D u_input;',\n\t\t'uniform float u_transformSize;',\n\t\t'uniform float u_subtransformSize;',\n\n\t\t'varying vec2 vUV;',\n\t\t\n\t\t'vec2 multiplyComplex (vec2 a, vec2 b) {',\n\t\t\t'return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);',\n\t\t'}',\n\n\t\t'void main (void) {',\n\t\t\t'#ifdef HORIZONTAL',\n\t\t\t\t'float index = vUV.x * u_transformSize - 0.5;',\n\t\t\t'#else',\n\t\t\t\t'float index = vUV.y * u_transformSize - 0.5;',\n\t\t\t'#endif',\n\n\t\t\t'float evenIndex = floor(index / u_subtransformSize) * (u_subtransformSize * 0.5) + mod(index, u_subtransformSize * 0.5);',\n\n\t\t\t//transform two complex sequences simultaneously\n\t\t\t'#ifdef HORIZONTAL',\n\t\t\t\t'vec4 even = texture2D(u_input, vec2(evenIndex + 0.5, gl_FragCoord.y) / u_transformSize).rgba;',\n\t\t\t\t'vec4 odd = texture2D(u_input, vec2(evenIndex + u_transformSize * 0.5 + 0.5, gl_FragCoord.y) / u_transformSize).rgba;',\n\t\t\t'#else',\n\t\t\t\t'vec4 even = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + 0.5) / u_transformSize).rgba;',\n\t\t\t\t'vec4 odd = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + u_transformSize * 0.5 + 0.5) / u_transformSize).rgba;',\n\t\t\t'#endif',\n\n\t\t\t'float twiddleArgument = -2.0 * PI * (index / u_subtransformSize);',\n\t\t\t'vec2 twiddle = vec2(cos(twiddleArgument), sin(twiddleArgument));',\n\n\t\t\t'vec2 outputA = even.xy + multiplyComplex(twiddle, odd.xy);',\n\t\t\t'vec2 outputB = even.zw + multiplyComplex(twiddle, odd.zw);',\n\n\t\t\t'gl_FragColor = vec4(outputA, outputB);',\n\t\t'}'\n\t].join('\\n')\n};\nTHREE.ShaderLib['ocean_initial_spectrum'] = {\n\tuniforms: {\n\t\t\"u_wind\": { type: \"v2\", value: new THREE.Vector2(10.0, 10.0) },\n\t\t\"u_resolution\": { type: \"f\", value: 512.0 },\n\t\t\"u_size\": { type: \"f\", value: 250.0 },\n\t},\n\tfragmentShader: [\n\n\t\t'const float PI = 3.14159265359;',\n\t\t'const float G = 9.81;',\n\t\t'const float KM = 370.0;',\n\t\t'const float CM = 0.23;',\n\n\t\t'uniform vec2 u_wind;',\n\t\t'uniform float u_resolution;',\n\t\t'uniform float u_size;',\n\t\t\n\t\t'float square (float x) {',\n\t\t\t'return x * x;',\n\t\t'}',\n\n\t\t'float omega (float k) {',\n\t\t\t'return sqrt(G * k * (1.0 + square(k / KM)));',\n\t\t'}',\n\n\t\t'float tanh (float x) {',\n\t\t\t'return (1.0 - exp(-2.0 * x)) / (1.0 + exp(-2.0 * x));',\n\t\t'}',\n\n\t\t'void main (void) {',\n\t\t\t'vec2 coordinates = gl_FragCoord.xy - 0.5;',\n\t\t\t\n\t\t\t'float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;',\n\t\t\t'float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;',\n\t\t\t\n\t\t\t'vec2 K = (2.0 * PI * vec2(n, m)) / u_size;',\n\t\t\t'float k = length(K);',\n\t\t\t\n\t\t\t'float l_wind = length(u_wind);',\n\n\t\t\t'float Omega = 0.84;',\n\t\t\t'float kp = G * square(Omega / l_wind);',\n\n\t\t\t'float c = omega(k) / k;',\n\t\t\t'float cp = omega(kp) / kp;',\n\n\t\t\t'float Lpm = exp(-1.25 * square(kp / k));',\n\t\t\t'float gamma = 1.7;',\n\t\t\t'float sigma = 0.08 * (1.0 + 4.0 * pow(Omega, -3.0));',\n\t\t\t'float Gamma = exp(-square(sqrt(k / kp) - 1.0) / 2.0 * square(sigma));',\n\t\t\t'float Jp = pow(gamma, Gamma);',\n\t\t\t'float Fp = Lpm * Jp * exp(-Omega / sqrt(10.0) * (sqrt(k / kp) - 1.0));',\n\t\t\t'float alphap = 0.006 * sqrt(Omega);',\n\t\t\t'float Bl = 0.5 * alphap * cp / c * Fp;',\n\n\t\t\t'float z0 = 0.000037 * square(l_wind) / G * pow(l_wind / cp, 0.9);',\n\t\t\t'float uStar = 0.41 * l_wind / log(10.0 / z0);',\n\t\t\t'float alpham = 0.01 * ((uStar < CM) ? (1.0 + log(uStar / CM)) : (1.0 + 3.0 * log(uStar / CM)));',\n\t\t\t'float Fm = exp(-0.25 * square(k / KM - 1.0));',\n\t\t\t'float Bh = 0.5 * alpham * CM / c * Fm * Lpm;',\n\n\t\t\t'float a0 = log(2.0) / 4.0;',\n\t\t\t'float am = 0.13 * uStar / CM;',\n\t\t\t'float Delta = tanh(a0 + 4.0 * pow(c / cp, 2.5) + am * pow(CM / c, 2.5));',\n\n\t\t\t'float cosPhi = dot(normalize(u_wind), normalize(K));',\n\n\t\t\t'float S = (1.0 / (2.0 * PI)) * pow(k, -4.0) * (Bl + Bh) * (1.0 + Delta * (2.0 * cosPhi * cosPhi - 1.0));',\n\n\t\t\t'float dk = 2.0 * PI / u_size;',\n\t\t\t'float h = sqrt(S / 2.0) * dk;',\n\n\t\t\t'if (K.x == 0.0 && K.y == 0.0) {',\n\t\t\t\t'h = 0.0;', //no DC term\n\t\t\t'}',\n\t\t\t'gl_FragColor = vec4(h, 0.0, 0.0, 0.0);',\n\t\t'}'\n\t].join('\\n')\n};\nTHREE.ShaderLib['ocean_phase'] = {\n\tuniforms: {\n\t\t\"u_phases\": { type: \"t\", value: null },\n\t\t\"u_deltaTime\": { type: \"f\", value: null },\n\t\t\"u_resolution\": { type: \"f\", value: null },\n\t\t\"u_size\": { type: \"f\", value: null },\n\t},\n\tvarying: {\n\t\t\"vUV\": { type: \"v2\" }\n\t},\n\tfragmentShader: [\n\n\t\t'const float PI = 3.14159265359;',\n\t\t'const float G = 9.81;',\n\t\t'const float KM = 370.0;',\n\n\t\t'varying vec2 vUV;',\n\n\t\t'uniform sampler2D u_phases;',\n\t\t'uniform float u_deltaTime;',\n\t\t'uniform float u_resolution;',\n\t\t'uniform float u_size;',\n\n\t\t'float omega (float k) {',\n\t\t\t'return sqrt(G * k * (1.0 + k * k / KM * KM));',\n\t\t'}',\n\n\t\t'void main (void) {',\n\t\t\t'vec2 coordinates = gl_FragCoord.xy - 0.5;',\n\t\t\t'float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;',\n\t\t\t'float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;',\n\t\t\t'vec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;',\n\n\t\t\t'float phase = texture2D(u_phases, vUV).r;',\n\t\t\t'float deltaPhase = omega(length(waveVector)) * u_deltaTime;',\n\t\t\t'phase = mod(phase + deltaPhase, 2.0 * PI);',\n\t\t\n\t\t\t'gl_FragColor = vec4(phase, 0.0, 0.0, 0.0);',\n\t\t'}'\n\t].join('\\n')\n};\nTHREE.ShaderLib['ocean_spectrum'] = {\n\tuniforms: {\n\t\t\"u_size\": { type: \"f\", value: null },\n\t\t\"u_resolution\": { type: \"f\", value: null },\n\t\t\"u_choppiness\": { type: \"f\", value: null },\n\t\t\"u_phases\": { type: \"t\", value: null },\n\t\t\"u_initialSpectrum\": { type: \"t\", value: null },\n\t},\n\tvarying: {\n\t\t\"vUV\": { type: \"v2\" }\n\t},\n\tfragmentShader: [\n\n\t\t'const float PI = 3.14159265359;',\n\t\t'const float G = 9.81;',\n\t\t'const float KM = 370.0;',\n\n\t\t'varying vec2 vUV;',\n\n\t\t'uniform float u_size;',\n\t\t'uniform float u_resolution;',\n\t\t'uniform float u_choppiness;',\n\t\t'uniform sampler2D u_phases;',\n\t\t'uniform sampler2D u_initialSpectrum;',\n\n\t\t'vec2 multiplyComplex (vec2 a, vec2 b) {',\n\t\t\t'return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);',\n\t\t'}',\n\n\t\t'vec2 multiplyByI (vec2 z) {',\n\t\t\t'return vec2(-z[1], z[0]);',\n\t\t'}',\n\n\t\t'float omega (float k) {',\n\t\t\t'return sqrt(G * k * (1.0 + k * k / KM * KM));',\n\t\t'}',\n\n\t\t'void main (void) {',\n\t\t\t'vec2 coordinates = gl_FragCoord.xy - 0.5;',\n\t\t\t'float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;',\n\t\t\t'float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;',\n\t\t\t'vec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;',\n\n\t\t\t'float phase = texture2D(u_phases, vUV).r;',\n\t\t\t'vec2 phaseVector = vec2(cos(phase), sin(phase));',\n\n\t\t\t'vec2 h0 = texture2D(u_initialSpectrum, vUV).rg;',\n\t\t\t'vec2 h0Star = texture2D(u_initialSpectrum, vec2(1.0 - vUV + 1.0 / u_resolution)).rg;',\n\t\t\t'h0Star.y *= -1.0;',\n\n\t\t\t'vec2 h = multiplyComplex(h0, phaseVector) + multiplyComplex(h0Star, vec2(phaseVector.x, -phaseVector.y));',\n\n\t\t\t'vec2 hX = -multiplyByI(h * (waveVector.x / length(waveVector))) * u_choppiness;',\n\t\t\t'vec2 hZ = -multiplyByI(h * (waveVector.y / length(waveVector))) * u_choppiness;',\n\n\t\t\t//no DC term\n\t\t\t'if (waveVector.x == 0.0 && waveVector.y == 0.0) {',\n\t\t\t\t'h = vec2(0.0);',\n\t\t\t\t'hX = vec2(0.0);',\n\t\t\t\t'hZ = vec2(0.0);',\n\t\t\t'}',\n\t\t\n\t\t\t'gl_FragColor = vec4(hX + multiplyByI(h), hZ);',\n\t\t'}'\n\t].join('\\n')\n};\nTHREE.ShaderLib['ocean_normals'] = {\n\tuniforms: {\n\t\t\"u_displacementMap\": { type: \"t\", value: null },\n\t\t\"u_resolution\": { type: \"f\", value: null },\n\t\t\"u_size\": { type: \"f\", value: null },\n\t},\n\tvarying: {\n\t\t\"vUV\": { type: \"v2\" }\n\t},\n\tfragmentShader: [\n\n\t\t'varying vec2 vUV;',\n\t\t\n\t\t'uniform sampler2D u_displacementMap;',\n\t\t'uniform float u_resolution;',\n\t\t'uniform float u_size;',\n\n\t\t'void main (void) {',\n\t\t\t'float texel = 1.0 / u_resolution;',\n\t\t\t'float texelSize = u_size / u_resolution;',\n\n\t\t\t'vec3 center = texture2D(u_displacementMap, vUV).rgb;',\n\t\t\t'vec3 right = vec3(texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(texel, 0.0)).rgb - center;',\n\t\t\t'vec3 left = vec3(-texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(-texel, 0.0)).rgb - center;',\n\t\t\t'vec3 top = vec3(0.0, 0.0, -texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, -texel)).rgb - center;',\n\t\t\t'vec3 bottom = vec3(0.0, 0.0, texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, texel)).rgb - center;',\n\n\t\t\t'vec3 topRight = cross(right, top);',\n\t\t\t'vec3 topLeft = cross(top, left);',\n\t\t\t'vec3 bottomLeft = cross(left, bottom);',\n\t\t\t'vec3 bottomRight = cross(bottom, right);',\n\t\t\n\t\t\t'gl_FragColor = vec4(normalize(topRight + topLeft + bottomLeft + bottomRight), 1.0);',\n\t\t'}'\n\t].join('\\n')\n};\n\nTHREE.UniformsLib[ \"oceanfft\" ] = {\n\n\t\"u_displacementMap\": { type: \"t\", value: null },\n\t\"u_reflection\": { type: \"t\", value: null },\n\t\"u_normalMap\": { type: \"t\", value: null },\n\t\"u_geometrySize\": { type: \"f\", value: null },\n\t\"u_size\": { type: \"f\", value: null },\n\t\"u_mirrorMatrix\": { type: \"m4\", value: null },\n\t\"u_cameraPosition\": { type: \"v3\", value: null },\n\t\"u_skyColor\": { type: \"v3\", value: null },\n\t\"u_oceanColor\": { type: \"v3\", value: null },\n\t\"u_sunDirection\": { type: \"v3\", value: null },\n\t\"u_exposure\": { type: \"f\", value: null },\n\n},\n\nTHREE.ShaderChunk[ \"oceanfft_pars_vertex\" ] = [\n\n\t'uniform sampler2D u_displacementMap;',\n\t'uniform float u_geometrySize;',\n\t'uniform float u_size;',\n\t\t\n].join('\\n');\n\nTHREE.ShaderChunk[ \"oceanfft_vertex\" ] = [\n\n\t'vec3 displacement = texture2D( u_displacementMap, worldPosition.xz * 0.002 ).rgb * ( u_geometrySize / u_size );',\n\t'vec4 oceanfftWorldPosition = worldPosition + vec4( displacement, 0.0 );',\n\t\n].join('\\n');\n\nTHREE.ShaderChunk[ \"oceanfft_pars_fragment\" ] = [\n  \n].join('\\n');\n\nTHREE.ShaderChunk[ \"oceanfft_fragment\" ] = [\n\t\n].join('\\n');\n"],"names":[],"version":3,"file":"index.a904aba2.js.map","sourceRoot":"/__parcel_source_root/"}