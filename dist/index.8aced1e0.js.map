{"mappings":"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","sources":["<anon>","js/effects/MirrorRenderer.js"],"sourcesContent":["THREE.MirrorRenderer = function(renderer, camera, scene, options) {\n    THREE.Object3D.call(this);\n    this.name = \"mirror_\" + this.id;\n    function optionalParameter(value, defaultValue) {\n        return value !== undefined ? value : defaultValue;\n    }\n    options = options || {};\n    this.matrixNeedsUpdate = true;\n    var width = optionalParameter(options.textureWidth, 512);\n    var height = optionalParameter(options.textureHeight, 512);\n    this.clipBias = optionalParameter(options.clipBias, 0.0);\n    this.renderer = renderer;\n    this.scene = scene;\n    this.mirrorPlane = new THREE.Plane();\n    this.normal = new THREE.Vector3(0, 0, 1);\n    this.cameraWorldPosition = new THREE.Vector3();\n    this.rotationMatrix = new THREE.Matrix4();\n    this.lookAtPosition = new THREE.Vector3(0, 0, -1);\n    this.clipPlane = new THREE.Vector4();\n    if (camera instanceof THREE.PerspectiveCamera) this.camera = camera;\n    else {\n        this.camera = new THREE.PerspectiveCamera();\n        console.log(this.name + \": camera is not a Perspective Camera!\");\n    }\n    this.textureMatrix = new THREE.Matrix4();\n    this.mirrorCamera = this.camera.clone();\n    this.mesh = new THREE.Object3D();\n    this.texture = new THREE.WebGLRenderTarget(width, height);\n    this.tempTexture = new THREE.WebGLRenderTarget(width, height);\n    if (!THREE.Math.isPowerOfTwo(width) || !THREE.Math.isPowerOfTwo(height)) {\n        this.texture.generateMipmaps = false;\n        this.tempTexture.generateMipmaps = false;\n    }\n    this.updateTextureMatrix();\n    this.render();\n};\nTHREE.MirrorRenderer.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.MirrorRenderer.prototype.renderWithMirror = function(otherMirror) {\n    // update the mirror matrix to mirror the current view\n    this.updateTextureMatrix();\n    this.matrixNeedsUpdate = false;\n    // set the camera of the other mirror so the mirrored view is the reference view\n    var tempCamera = otherMirror.camera;\n    otherMirror.camera = this.mirrorCamera;\n    // render the other mirror in temp texture\n    otherMirror.render(true);\n    otherMirror.material.uniforms.mirrorSampler.value = otherMirror.tempTexture;\n    // render the current mirror\n    this.render();\n    this.matrixNeedsUpdate = true;\n    // restore material and camera of other mirror\n    otherMirror.material.uniforms.mirrorSampler.value = otherMirror.texture;\n    otherMirror.camera = tempCamera;\n    // restore texture matrix of other mirror\n    otherMirror.updateTextureMatrix();\n};\nTHREE.MirrorRenderer.prototype.updateTextureMatrix = function() {\n    if (this.parent != undefined) this.mesh = this.parent;\n    function sign(x) {\n        return x ? x < 0 ? -1 : 1 : 0;\n    }\n    this.updateMatrixWorld();\n    this.camera.updateMatrixWorld();\n    this.cameraWorldPosition.setFromMatrixPosition(this.camera.matrixWorld);\n    this.rotationMatrix.extractRotation(this.matrixWorld);\n    this.normal = new THREE.Vector3(0, 1, 0).applyEuler(this.mesh.rotation);\n    var cameraLookAt = new THREE.Vector3(0, 0, 1).applyEuler(this.camera.rotation);\n    if (this.normal.dot(cameraLookAt) < 0) {\n        var meshNormal = new THREE.Vector3(0, 0, 1).applyEuler(this.mesh.rotation);\n        this.normal.reflect(meshNormal);\n    }\n    var view = this.mesh.position.clone().sub(this.cameraWorldPosition);\n    //view.y -= 0.1;\n    view.reflect(this.normal).negate();\n    view.add(this.mesh.position);\n    this.rotationMatrix.extractRotation(this.camera.matrixWorld);\n    this.lookAtPosition.set(0, 0, -1);\n    this.lookAtPosition.applyMatrix4(this.rotationMatrix);\n    this.lookAtPosition.add(this.cameraWorldPosition);\n    var target = this.mesh.position.clone().sub(this.lookAtPosition);\n    target.reflect(this.normal).negate();\n    target.add(this.mesh.position);\n    this.up.set(0, -1, 0);\n    this.up.applyMatrix4(this.rotationMatrix);\n    this.up.reflect(this.normal).negate();\n    this.mirrorCamera.position.copy(view);\n    this.mirrorCamera.up = this.up;\n    this.mirrorCamera.lookAt(target);\n    this.mirrorCamera.aspect = this.camera.aspect;\n    this.mirrorCamera.updateProjectionMatrix();\n    this.mirrorCamera.updateMatrixWorld();\n    this.mirrorCamera.matrixWorldInverse.getInverse(this.mirrorCamera.matrixWorld);\n    // Update the texture matrix\n    this.textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    this.textureMatrix.multiply(this.mirrorCamera.projectionMatrix);\n    this.textureMatrix.multiply(this.mirrorCamera.matrixWorldInverse);\n    // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n    this.mirrorPlane.setFromNormalAndCoplanarPoint(this.normal, this.mesh.position);\n    this.mirrorPlane.applyMatrix4(this.mirrorCamera.matrixWorldInverse);\n    this.clipPlane.set(this.mirrorPlane.normal.x, this.mirrorPlane.normal.y, this.mirrorPlane.normal.z, this.mirrorPlane.constant);\n    var q = new THREE.Vector4();\n    var projectionMatrix = this.mirrorCamera.projectionMatrix;\n    q.x = (sign(this.clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n    q.y = (sign(this.clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n    q.z = -1;\n    q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n    // Calculate the scaled plane vector\n    var c = new THREE.Vector4();\n    c = this.clipPlane.multiplyScalar(2.0 / this.clipPlane.dot(q));\n    // Replacing the third row of the projection matrix\n    projectionMatrix.elements[2] = c.x;\n    projectionMatrix.elements[6] = c.y;\n    projectionMatrix.elements[10] = c.z + 1.0 - this.clipBias;\n    projectionMatrix.elements[14] = c.w;\n    var worldCoordinates = new THREE.Vector3();\n    worldCoordinates.setFromMatrixPosition(this.camera.matrixWorld);\n    this.eye = worldCoordinates;\n};\nTHREE.MirrorRenderer.prototype.render = function(isTempTexture) {\n    if (this.matrixNeedsUpdate) this.updateTextureMatrix();\n    this.matrixNeedsUpdate = true;\n    // Render the mirrored view of the current scene into the target texture\n    if (this.scene !== undefined && this.scene instanceof THREE.Scene) {\n        var renderTexture = isTempTexture !== undefined && isTempTexture ? this.tempTexture : this.texture;\n        this.renderer.render(this.scene, this.mirrorCamera, renderTexture, true);\n    }\n};\n\n//# sourceMappingURL=index.8aced1e0.js.map\n","\n\nTHREE.MirrorRenderer = function (renderer, camera, scene, options) {\n\t\n\tTHREE.Object3D.call(this);\n\tthis.name = 'mirror_' + this.id;\n\n\tfunction optionalParameter (value, defaultValue) {\n\t\treturn value !== undefined ? value : defaultValue;\n\t};\n\n\toptions = options || {};\n\t\n\tthis.matrixNeedsUpdate = true;\n\t\n\tvar width = optionalParameter(options.textureWidth, 512);\n\tvar height = optionalParameter(options.textureHeight, 512);\n\tthis.clipBias = optionalParameter(options.clipBias, 0.0);\n\t\n\tthis.renderer = renderer;\n\tthis.scene = scene;\n\tthis.mirrorPlane = new THREE.Plane();\n\tthis.normal = new THREE.Vector3(0, 0, 1);\n\tthis.cameraWorldPosition = new THREE.Vector3();\n\tthis.rotationMatrix = new THREE.Matrix4();\n\tthis.lookAtPosition = new THREE.Vector3(0, 0, -1);\n\tthis.clipPlane = new THREE.Vector4();\n\t\n\tif ( camera instanceof THREE.PerspectiveCamera ) {\n\t\tthis.camera = camera;\n\t}\n\telse  {\n\t\tthis.camera = new THREE.PerspectiveCamera();\n\t\tconsole.log(this.name + ': camera is not a Perspective Camera!')\n\t}\n\n\tthis.textureMatrix = new THREE.Matrix4();\n\n\tthis.mirrorCamera = this.camera.clone();\n\t\n\tthis.mesh = new THREE.Object3D();\n\t\n\tthis.texture = new THREE.WebGLRenderTarget(width, height);\n\tthis.tempTexture = new THREE.WebGLRenderTarget(width, height);\n\t\n\tif ( !THREE.Math.isPowerOfTwo(width) || !THREE.Math.isPowerOfTwo(height) ) {\n\t\tthis.texture.generateMipmaps = false;\n\t\tthis.tempTexture.generateMipmaps = false;\n\t}\n\n\tthis.updateTextureMatrix();\n\tthis.render();\n};\n\nTHREE.MirrorRenderer.prototype = Object.create(THREE.Object3D.prototype);\n\nTHREE.MirrorRenderer.prototype.renderWithMirror = function (otherMirror) {\n\n\t// update the mirror matrix to mirror the current view\n\tthis.updateTextureMatrix();\n\tthis.matrixNeedsUpdate = false;\n\n\t// set the camera of the other mirror so the mirrored view is the reference view\n\tvar tempCamera = otherMirror.camera;\n\totherMirror.camera = this.mirrorCamera;\n\n\t// render the other mirror in temp texture\n\totherMirror.render(true);\n\totherMirror.material.uniforms.mirrorSampler.value = otherMirror.tempTexture;\n\n\t// render the current mirror\n\tthis.render();\n\tthis.matrixNeedsUpdate = true;\n\n\t// restore material and camera of other mirror\n\totherMirror.material.uniforms.mirrorSampler.value = otherMirror.texture;\n\totherMirror.camera = tempCamera;\n\n\t// restore texture matrix of other mirror\n\totherMirror.updateTextureMatrix();\n};\n\nTHREE.MirrorRenderer.prototype.updateTextureMatrix = function () {\n\n\tif ( this.parent != undefined ) {\n\t\tthis.mesh = this.parent;\n\t}\n\n\tfunction sign(x) { return x ? x < 0 ? -1 : 1 : 0; }\n\n\tthis.updateMatrixWorld();\n\tthis.camera.updateMatrixWorld();\n\n\tthis.cameraWorldPosition.setFromMatrixPosition(this.camera.matrixWorld);\n\n\tthis.rotationMatrix.extractRotation(this.matrixWorld);\n\n\tthis.normal = (new THREE.Vector3(0, 1, 0)).applyEuler(this.mesh.rotation);\n\tvar cameraLookAt = (new THREE.Vector3(0, 0, 1)).applyEuler(this.camera.rotation);\n\tif ( this.normal.dot(cameraLookAt) < 0 ) {\n\t\tvar meshNormal = (new THREE.Vector3(0, 0, 1)).applyEuler(this.mesh.rotation);\n\t\tthis.normal.reflect(meshNormal);\n\t}\n\n\tvar view = this.mesh.position.clone().sub(this.cameraWorldPosition);\n\t//view.y -= 0.1;\n\tview.reflect(this.normal).negate();\n\tview.add(this.mesh.position);\n\n\tthis.rotationMatrix.extractRotation(this.camera.matrixWorld);\n\n\tthis.lookAtPosition.set(0, 0, -1);\n\tthis.lookAtPosition.applyMatrix4(this.rotationMatrix);\n\tthis.lookAtPosition.add(this.cameraWorldPosition);\n\n\tvar target = this.mesh.position.clone().sub(this.lookAtPosition);\n\ttarget.reflect(this.normal).negate();\n\ttarget.add(this.mesh.position);\n\n\tthis.up.set(0, -1, 0);\n\tthis.up.applyMatrix4(this.rotationMatrix);\n\tthis.up.reflect(this.normal).negate();\n\n\tthis.mirrorCamera.position.copy(view);\n\tthis.mirrorCamera.up = this.up;\n\tthis.mirrorCamera.lookAt(target);\n\tthis.mirrorCamera.aspect = this.camera.aspect;\n\n\tthis.mirrorCamera.updateProjectionMatrix();\n\tthis.mirrorCamera.updateMatrixWorld();\n\tthis.mirrorCamera.matrixWorldInverse.getInverse(this.mirrorCamera.matrixWorld);\n\n\t// Update the texture matrix\n\tthis.textureMatrix.set(0.5, 0.0, 0.0, 0.5,\n\t\t\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t\t\t\t0.0, 0.0, 0.0, 1.0);\n\tthis.textureMatrix.multiply(this.mirrorCamera.projectionMatrix);\n\tthis.textureMatrix.multiply(this.mirrorCamera.matrixWorldInverse);\n\n\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\tthis.mirrorPlane.setFromNormalAndCoplanarPoint(this.normal, this.mesh.position);\n\tthis.mirrorPlane.applyMatrix4(this.mirrorCamera.matrixWorldInverse);\n\n\tthis.clipPlane.set(this.mirrorPlane.normal.x, this.mirrorPlane.normal.y, this.mirrorPlane.normal.z, this.mirrorPlane.constant);\n\n\tvar q = new THREE.Vector4();\n\tvar projectionMatrix = this.mirrorCamera.projectionMatrix;\n\n\tq.x = (sign(this.clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n\tq.y = (sign(this.clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n\tq.z = -1.0;\n\tq.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n\n\t// Calculate the scaled plane vector\n\tvar c = new THREE.Vector4();\n\tc = this.clipPlane.multiplyScalar(2.0 / this.clipPlane.dot(q));\n\n\t// Replacing the third row of the projection matrix\n\tprojectionMatrix.elements[2] = c.x;\n\tprojectionMatrix.elements[6] = c.y;\n\tprojectionMatrix.elements[10] = c.z + 1.0 - this.clipBias;\n\tprojectionMatrix.elements[14] = c.w;\n\t\n\tvar worldCoordinates = new THREE.Vector3();\n\tworldCoordinates.setFromMatrixPosition(this.camera.matrixWorld);\n\tthis.eye = worldCoordinates;\n};\n\nTHREE.MirrorRenderer.prototype.render = function (isTempTexture) {\n\n\tif ( this.matrixNeedsUpdate ) {\n\t\tthis.updateTextureMatrix();\n\t}\n\n\tthis.matrixNeedsUpdate = true;\n\n\t// Render the mirrored view of the current scene into the target texture\n\tif ( this.scene !== undefined && this.scene instanceof THREE.Scene ) {\n\t\tvar renderTexture = (isTempTexture !== undefined && isTempTexture)? this.tempTexture : this.texture;\n        this.renderer.render(this.scene, this.mirrorCamera, renderTexture, true);\n\t}\n\n};"],"names":["THREE","MirrorRenderer","renderer","camera","scene","options","optionalParameter","value","defaultValue","undefined","Object3D","call","name","id","matrixNeedsUpdate","width","textureWidth","height","textureHeight","clipBias","mirrorPlane","Plane","normal","Vector3","cameraWorldPosition","rotationMatrix","Matrix4","lookAtPosition","clipPlane","Vector4","PerspectiveCamera","console","log","textureMatrix","mirrorCamera","clone","mesh","texture","WebGLRenderTarget","tempTexture","Math","isPowerOfTwo","generateMipmaps","updateTextureMatrix","render","prototype","Object","create","renderWithMirror","otherMirror","tempCamera","material","uniforms","mirrorSampler","parent","updateMatrixWorld","setFromMatrixPosition","matrixWorld","extractRotation","applyEuler","rotation","x","cameraLookAt","dot","meshNormal","reflect","view","position","sub","negate","add","set","applyMatrix4","target","up","copy","lookAt","aspect","updateProjectionMatrix","matrixWorldInverse","getInverse","multiply","projectionMatrix","setFromNormalAndCoplanarPoint","y","z","constant","q","sign","elements","w","c","multiplyScalar","worldCoordinates","eye","isTempTexture","Scene","renderTexture"],"version":3,"file":"index.8aced1e0.js.map"}