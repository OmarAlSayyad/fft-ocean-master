{"mappings":"ACIA,MAAM,WAAW,CAAC,uBAA0B,CAAG,uhDAqF/C,MAAM,WAAW,CAAC,kBAAqB,CAAG,2EAI1C,MAAM,WAAW,CAAC,yBAA4B,CAAG","sources":["<anon>","js/shaders/ScreenSpaceShader.js"],"sourcesContent":["/**\n * @author jbouny / https://github.com/fft-ocean\n */ THREE.ShaderChunk[\"screenplane_pars_vertex\"] = [\n    \"const float infinite = 150000.0;\",\n    \"const float screenScale = 1.2;\",\n    \"const vec3 groundNormal = vec3( 0.0, 1.0, 0.0 );\",\n    \"const float groundHeight = 0.0;\",\n    \"varying vec3 vCamPosition;\",\n    \"vec3 interceptPlane( in vec3 source, in vec3 dir, in vec3 normal, float height )\",\n    \"{\",\n    // Compute the distance between the source and the surface, following a ray, then return the intersection\n    // http://www.cs.rpi.edu/~cutler/classes/advancedgraphics/S09/lectures/11_ray_tracing.pdf\n    \"\tfloat distance = ( - height - dot( normal, source ) ) / dot( normal, dir );\",\n    \"\tif( distance < 0.0 )\",\n    \"\t\treturn source + dir * distance;\",\n    \"\telse \",\n    \"\t\treturn - ( vec3( source.x, height, source.z ) + vec3( dir.x, height, dir.z ) * infinite );\",\n    \"}\",\n    \"mat3 getRotation()\",\n    \"{\",\n    // Extract the 3x3 rotation matrix from the 4x4 view matrix\n    \"\treturn mat3( \",\n    \"\t\tviewMatrix[0].xyz,\",\n    \"\t\tviewMatrix[1].xyz,\",\n    \"\t\tviewMatrix[2].xyz\",\n    \"\t);\",\n    \"}\",\n    \"vec3 getCameraPos( in mat3 rotation )\",\n    \"{\",\n    // Xc = R * Xw + t\n    // c = - R.t() * t <=> c = - t.t() * R\n    \"\treturn - viewMatrix[3].xyz * rotation;\",\n    \"}\",\n    \"vec2 getImagePlan()\",\n    \"{\",\n    // Extracting aspect and focal from projection matrix:\n    // P = | e   0       0   0 |\n    //     | 0   e/(h/w) 0   0 |\n    //     | 0   0       .   . |\n    //     | 0   0       -1  0 |\n    \"\tfloat focal = projectionMatrix[0].x;\",\n    \"\tfloat aspect = projectionMatrix[1].y;\",\n    // Fix coordinate aspect and scale\n    \"\treturn vec2( ( uv.x - 0.5 ) * screenScale * aspect, ( uv.y - 0.5 ) * screenScale * focal );\",\n    \"}\",\n    \"vec3 getCamRay( in mat3 rotation, in vec2 screenUV )\",\n    \"{\",\n    // Compute camera ray then rotate it in order to get it in world coordinate\n    \"\treturn vec3( screenUV.x, screenUV.y, projectionMatrix[0].x ) * rotation;\",\n    \"}\",\n    \"vec3 computeProjectedPosition()\",\n    \"{\",\n    // Extract camera position and rotation from the model view matrix\n    \"\tmat3 cameraRotation = getRotation();\",\n    \"\tvec3 camPosition = getCameraPos( cameraRotation );\",\n    \"\tvCamPosition = camPosition;\",\n    // Return the intersection between the camera ray and a given plane\n    \"\tif( camPosition.y < groundHeight )\",\n    \"\t\treturn vec3( 0.0, 0.0, 0.0 );\",\n    // Extract coordinate of the vertex on the image plan\n    \"\tvec2 screenUV = getImagePlan() ;\",\n    // Compute the ray from camera to world\n    \"\tvec3 ray = getCamRay( cameraRotation, screenUV );\",\n    \"\tvec3 finalPos = interceptPlane( camPosition, ray, groundNormal, groundHeight );\",\n    \"\tfloat distance = length( finalPos );\",\n    \"\tif( distance > infinite )\",\n    \"\t\tfinalPos *= infinite / distance;\",\n    \"\treturn finalPos;\",\n    \"}\"\n].join(\"\\n\");\nTHREE.ShaderChunk[\"screenplane_vertex\"] = [\n    \"vec4 screenPlaneWorldPosition = vec4( computeProjectedPosition(), 1.0 );\"\n].join(\"\\n\");\nTHREE.ShaderChunk[\"screenplane_pars_fragment\"] = [\n    \"varying vec3 vCamPosition;\"\n].join(\"\\n\");\n\n//# sourceMappingURL=index.661394b8.js.map\n","/**\n * @author jbouny / https://github.com/fft-ocean\n */\n \nTHREE.ShaderChunk[\"screenplane_pars_vertex\"] = [\n\t\t\n\t\t'const float infinite = 150000.0;',\n\t\t'const float screenScale = 1.2;',\n\t\t'const vec3 groundNormal = vec3( 0.0, 1.0, 0.0 );',\n\t\t'const float groundHeight = 0.0;',\n\t\t\n\t\t'varying vec3 vCamPosition;',\n\t\t\n\t\t'vec3 interceptPlane( in vec3 source, in vec3 dir, in vec3 normal, float height )',\n\t\t'{',\n\t\t\t// Compute the distance between the source and the surface, following a ray, then return the intersection\n      // http://www.cs.rpi.edu/~cutler/classes/advancedgraphics/S09/lectures/11_ray_tracing.pdf\n\t\t'\tfloat distance = ( - height - dot( normal, source ) ) / dot( normal, dir );',\n\t\t'\tif( distance < 0.0 )',\n\t\t'\t\treturn source + dir * distance;',\n\t\t'\telse ',\n\t\t'\t\treturn - ( vec3( source.x, height, source.z ) + vec3( dir.x, height, dir.z ) * infinite );',\n\t\t'}',\n\t\t\n\t\t'mat3 getRotation()',\n\t\t'{',\n\t\t\t// Extract the 3x3 rotation matrix from the 4x4 view matrix\n\t\t'\treturn mat3( ',\n\t\t'\t\tviewMatrix[0].xyz,',\n\t\t'\t\tviewMatrix[1].xyz,',\n\t\t'\t\tviewMatrix[2].xyz',\n\t\t'\t);',\n\t\t'}',\n\t\t\n\t\t'vec3 getCameraPos( in mat3 rotation )',\n\t\t'{',\n\t\t\t// Xc = R * Xw + t\n\t\t\t// c = - R.t() * t <=> c = - t.t() * R\n\t\t'\treturn - viewMatrix[3].xyz * rotation;',\n\t\t'}',\n\n\t\t'vec2 getImagePlan()',\n\t\t'{',\n\t\t\t// Extracting aspect and focal from projection matrix:\n\t\t\t// P = | e   0       0   0 |\n\t\t\t//     | 0   e/(h/w) 0   0 |\n\t\t\t//     | 0   0       .   . |\n\t\t\t//     | 0   0       -1  0 |\n\t\t'\tfloat focal = projectionMatrix[0].x;',\n\t\t'\tfloat aspect = projectionMatrix[1].y;',\n\t\t\t\n\t\t\t// Fix coordinate aspect and scale\n\t\t'\treturn vec2( ( uv.x - 0.5 ) * screenScale * aspect, ( uv.y - 0.5 ) * screenScale * focal );',\n\t\t'}',\n\t\t\n\t\t'vec3 getCamRay( in mat3 rotation, in vec2 screenUV )',\n\t\t'{',\n\t\t\t// Compute camera ray then rotate it in order to get it in world coordinate\n\t\t'\treturn vec3( screenUV.x, screenUV.y, projectionMatrix[0].x ) * rotation;',\n\t\t'}',\n\t\t\n\t\t'vec3 computeProjectedPosition()',\n\t\t'{',\n\t\t\t// Extract camera position and rotation from the model view matrix\n\t\t'\tmat3 cameraRotation = getRotation();',\n\t\t'\tvec3 camPosition = getCameraPos( cameraRotation );',\n\t\t'\tvCamPosition = camPosition;',\n\t\t\n\t\t\t// Return the intersection between the camera ray and a given plane\n\t\t'\tif( camPosition.y < groundHeight )',\n\t\t'\t\treturn vec3( 0.0, 0.0, 0.0 );',\n\t\t\n\t\t\t// Extract coordinate of the vertex on the image plan\n\t\t'\tvec2 screenUV = getImagePlan() ;',\n\t\t\t\n\t\t\t// Compute the ray from camera to world\n\t\t'\tvec3 ray = getCamRay( cameraRotation, screenUV );',\n\t\t\t\n\t\t'\tvec3 finalPos = interceptPlane( camPosition, ray, groundNormal, groundHeight );',\n\t\t\n\t\t'\tfloat distance = length( finalPos );',\n\t\t'\tif( distance > infinite )',\n\t\t'\t\tfinalPos *= infinite / distance;',\n\t\t\n\t\t'\treturn finalPos;',\n\t\t'}'\n\t\n].join('\\n');\n\nTHREE.ShaderChunk[\"screenplane_vertex\"] = [\n\t'vec4 screenPlaneWorldPosition = vec4( computeProjectedPosition(), 1.0 );',\n].join('\\n');\n\nTHREE.ShaderChunk[\"screenplane_pars_fragment\"] = [\n\t\t'varying vec3 vCamPosition;'\n].join('\\n');"],"names":["THREE","ShaderChunk"],"version":3,"file":"index.661394b8.js.map"}