{"mappings":"AAAA;;CAEC,GAGD,MAAM,SAAS,CAAC,aAAa,GAAG;IAC/B,UAAU,MAAM,WAAW,CAAE,WAAY;IAEzC,cAAc;QACb;QAEA;QACA;QAEA;QAEA,MAAM,WAAW,CAAE,0BAA2B;QAC9C,MAAM,WAAW,CAAE,uBAAwB;QAE3C;QACC,MAAM,WAAW,CAAE,qBAAsB;QAEzC;QAEA,MAAM,WAAW,CAAE,kBAAmB;QAEtC;QACA;QAEA;QACD;KACA,CAAC,IAAI,CAAC;IAEP,yBAAyB;QACxB;QAEA;QACA;QAEA;QAEA,MAAM,WAAW,CAAE,0BAA2B;QAC9C,MAAM,WAAW,CAAE,uBAAwB;QAE3C;QACC,MAAM,WAAW,CAAE,qBAAsB;QAEzC;QACA;QAEA;QACD;KACA,CAAC,IAAI,CAAC;IAEP,gBAAgB;QACf;QACA;QAEA;QACA;QACA;QACA;QACA;QAEA;QACC;QACD;QAEA,MAAM,WAAW,CAAC,4BAA4B;QAE9C;QACC;QACA;QAEA,8BAA8B;QAC9B;QACA;QAEA,uBAAuB;QACvB;QACA;QAEA,2CAA2C;QAC3C;QACA;QACA;QACA,yBAAyB;QACzB;QACA;QAEA,4BAA4B;QAC5B;QAEA,iDAAiD;QACjD;QACA;QAEA,0BAA0B;QAC1B;QACA;QAEA;QACD;KACA,CAAC,IAAI,CAAC;AACR","sources":["js/shaders/OceanShader.js"],"sourcesContent":["ï»¿/**\n * @author jbouny / https://github.com/fft-ocean\n */\n \n \nTHREE.ShaderLib['ocean_main'] = {\n\tuniforms: THREE.UniformsLib[ \"oceanfft\" ],\n  \n\tvertexShader: [\n\t\t'precision highp float;',\n\t\t\n\t\t'varying vec3 vWorldPosition;',\n\t\t'varying vec4 vReflectCoordinates;',\n\n\t\t'uniform mat4 u_mirrorMatrix;',\n\t\t\n\t\tTHREE.ShaderChunk[ \"screenplane_pars_vertex\" ],\n\t\tTHREE.ShaderChunk[ \"oceanfft_pars_vertex\" ],\n\n\t\t'void main (void) {',\n\t\t\tTHREE.ShaderChunk[ \"screenplane_vertex\" ],\n\t\t\t\n\t\t\t'vec4 worldPosition = screenPlaneWorldPosition;',\n\t\t\t\n\t\t\tTHREE.ShaderChunk[ \"oceanfft_vertex\" ],\n\t\t\t\n\t\t\t'vWorldPosition = oceanfftWorldPosition.xyz;',\n\t\t\t'vReflectCoordinates = u_mirrorMatrix * oceanfftWorldPosition;',\n\t\t\t\n\t\t\t'gl_Position = projectionMatrix * viewMatrix * oceanfftWorldPosition;',\n\t\t'}'\n\t].join('\\n'),\n  \n\tvertexShaderNoTexLookup: [\n\t\t'precision highp float;',\n\t\t\n\t\t'varying vec3 vWorldPosition;',\n\t\t'varying vec4 vReflectCoordinates;',\n\n\t\t'uniform mat4 u_mirrorMatrix;',\n\t\t\n\t\tTHREE.ShaderChunk[ \"screenplane_pars_vertex\" ],\n\t\tTHREE.ShaderChunk[ \"oceanfft_pars_vertex\" ],\n\n\t\t'void main (void) {',\n\t\t\tTHREE.ShaderChunk[ \"screenplane_vertex\" ],\n\t\t\t\n\t\t\t'vWorldPosition = screenPlaneWorldPosition.xyz;',\n\t\t\t'vReflectCoordinates = u_mirrorMatrix * screenPlaneWorldPosition;',\n\t\t\t\n\t\t\t'gl_Position = projectionMatrix * viewMatrix * screenPlaneWorldPosition;',\n\t\t'}'\n\t].join('\\n'),\n  \n\tfragmentShader: [\n\t\t'varying vec3 vWorldPosition;',\n\t\t'varying vec4 vReflectCoordinates;',\n\n\t\t'uniform sampler2D u_reflection;',\n\t\t'uniform sampler2D u_normalMap;',\n\t\t'uniform vec3 u_oceanColor;',\n\t\t'uniform vec3 u_sunDirection;',\n\t\t'uniform float u_exposure;',\n\n\t\t'vec3 hdr (vec3 color, float exposure) {',\n\t\t\t'return 1.0 - exp(-color * exposure);',\n\t\t'}',\n\t\t\n\t\tTHREE.ShaderChunk[\"screenplane_pars_fragment\"],\n\n\t\t'void main (void) {',\n\t\t\t'vec3 normal = texture2D( u_normalMap, vWorldPosition.xz * 0.002 ).rgb;',\n\t\t\t'vec3 view = normalize( vCamPosition - vWorldPosition );',\n\t\t\t\n\t\t\t// Compute the specular factor\n\t\t\t'vec3 reflection = normalize( reflect( -u_sunDirection, normal ) );',\n\t\t\t'float specularFactor = pow( max( 0.0, dot( view, reflection ) ), 500.0 ) * 20.0;',\n\t\t\n\t\t\t// Get reflection color\n\t\t\t'vec3 distortion = 200.0 * normal * vec3( 1.0, 0.0, 0.1 );',\t\n\t\t\t'vec3 reflectionColor = texture2DProj( u_reflection, vReflectCoordinates.xyz + distortion ).xyz;',\n\t\t\t\n\t\t\t// Smooth the normal following the distance\n\t\t\t'float distanceRatio = min( 1.0, log( 1.0 / length( vCamPosition - vWorldPosition ) * 3000.0 + 1.0 ) );',\n\t\t\t'distanceRatio *= distanceRatio;',\n\t\t\t'distanceRatio = distanceRatio * 0.7 + 0.3;',\n\t\t\t//'distanceRatio = 1.0;',\n\t\t\t'normal = ( distanceRatio * normal + vec3( 0.0, 1.0 - distanceRatio, 0.0 ) ) * 0.5;',\n\t\t\t'normal /= length( normal );',\n\t\t\t\n\t\t\t// Compute the fresnel ratio\n\t\t\t'float fresnel = pow( 1.0 - dot( normal, view ), 2.0 );',\n\t\t\t\n\t\t\t// Compute the sky reflection and the water color\n\t\t\t'float skyFactor = ( fresnel + 0.2 ) * 10.0;',\n\t\t\t'vec3 waterColor = ( 1.0 - fresnel ) * u_oceanColor;',\n\t\t\t\n\t\t\t// Compute the final color\n\t\t\t'vec3 color = ( skyFactor + specularFactor + waterColor ) * reflectionColor + waterColor * 0.5 ;',\n\t\t\t'color = hdr( color, u_exposure );',\n\n\t\t\t'gl_FragColor = vec4( color, 1.0 );',\n\t\t'}'\n\t].join('\\n')\n};"],"names":[],"version":3,"file":"index.68825b97.js.map","sourceRoot":"/__parcel_source_root/"}