THREE.ShaderLib.ocean_sim_vertex={varying:{vUV:{type:"v2"}},vertexShader:"varying vec2 vUV;\nvoid main (void) {\nvUV = position.xy * 0.5 + 0.5;\ngl_Position = vec4(position, 1.0 );\n}"},THREE.ShaderLib.ocean_subtransform={uniforms:{u_input:{type:"t",value:null},u_transformSize:{type:"f",value:512},u_subtransformSize:{type:"f",value:250}},varying:{vUV:{type:"v2"}},fragmentShader:"const float PI = 3.14159265359;\nuniform sampler2D u_input;\nuniform float u_transformSize;\nuniform float u_subtransformSize;\nvarying vec2 vUV;\nvec2 multiplyComplex (vec2 a, vec2 b) {\nreturn vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);\n}\nvoid main (void) {\n#ifdef HORIZONTAL\nfloat index = vUV.x * u_transformSize - 0.5;\n#else\nfloat index = vUV.y * u_transformSize - 0.5;\n#endif\nfloat evenIndex = floor(index / u_subtransformSize) * (u_subtransformSize * 0.5) + mod(index, u_subtransformSize * 0.5);\n#ifdef HORIZONTAL\nvec4 even = texture2D(u_input, vec2(evenIndex + 0.5, gl_FragCoord.y) / u_transformSize).rgba;\nvec4 odd = texture2D(u_input, vec2(evenIndex + u_transformSize * 0.5 + 0.5, gl_FragCoord.y) / u_transformSize).rgba;\n#else\nvec4 even = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + 0.5) / u_transformSize).rgba;\nvec4 odd = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + u_transformSize * 0.5 + 0.5) / u_transformSize).rgba;\n#endif\nfloat twiddleArgument = -2.0 * PI * (index / u_subtransformSize);\nvec2 twiddle = vec2(cos(twiddleArgument), sin(twiddleArgument));\nvec2 outputA = even.xy + multiplyComplex(twiddle, odd.xy);\nvec2 outputB = even.zw + multiplyComplex(twiddle, odd.zw);\ngl_FragColor = vec4(outputA, outputB);\n}"},THREE.ShaderLib.ocean_initial_spectrum={uniforms:{u_wind:{type:"v2",value:new THREE.Vector2(10,10)},u_resolution:{type:"f",value:512},u_size:{type:"f",value:250}},fragmentShader:"const float PI = 3.14159265359;\nconst float G = 9.81;\nconst float KM = 370.0;\nconst float CM = 0.23;\nuniform vec2 u_wind;\nuniform float u_resolution;\nuniform float u_size;\nfloat square (float x) {\nreturn x * x;\n}\nfloat omega (float k) {\nreturn sqrt(G * k * (1.0 + square(k / KM)));\n}\nfloat tanh (float x) {\nreturn (1.0 - exp(-2.0 * x)) / (1.0 + exp(-2.0 * x));\n}\nvoid main (void) {\nvec2 coordinates = gl_FragCoord.xy - 0.5;\nfloat n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;\nfloat m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;\nvec2 K = (2.0 * PI * vec2(n, m)) / u_size;\nfloat k = length(K);\nfloat l_wind = length(u_wind);\nfloat Omega = 0.84;\nfloat kp = G * square(Omega / l_wind);\nfloat c = omega(k) / k;\nfloat cp = omega(kp) / kp;\nfloat Lpm = exp(-1.25 * square(kp / k));\nfloat gamma = 1.7;\nfloat sigma = 0.08 * (1.0 + 4.0 * pow(Omega, -3.0));\nfloat Gamma = exp(-square(sqrt(k / kp) - 1.0) / 2.0 * square(sigma));\nfloat Jp = pow(gamma, Gamma);\nfloat Fp = Lpm * Jp * exp(-Omega / sqrt(10.0) * (sqrt(k / kp) - 1.0));\nfloat alphap = 0.006 * sqrt(Omega);\nfloat Bl = 0.5 * alphap * cp / c * Fp;\nfloat z0 = 0.000037 * square(l_wind) / G * pow(l_wind / cp, 0.9);\nfloat uStar = 0.41 * l_wind / log(10.0 / z0);\nfloat alpham = 0.01 * ((uStar < CM) ? (1.0 + log(uStar / CM)) : (1.0 + 3.0 * log(uStar / CM)));\nfloat Fm = exp(-0.25 * square(k / KM - 1.0));\nfloat Bh = 0.5 * alpham * CM / c * Fm * Lpm;\nfloat a0 = log(2.0) / 4.0;\nfloat am = 0.13 * uStar / CM;\nfloat Delta = tanh(a0 + 4.0 * pow(c / cp, 2.5) + am * pow(CM / c, 2.5));\nfloat cosPhi = dot(normalize(u_wind), normalize(K));\nfloat S = (1.0 / (2.0 * PI)) * pow(k, -4.0) * (Bl + Bh) * (1.0 + Delta * (2.0 * cosPhi * cosPhi - 1.0));\nfloat dk = 2.0 * PI / u_size;\nfloat h = sqrt(S / 2.0) * dk;\nif (K.x == 0.0 && K.y == 0.0) {\nh = 0.0;\n}\ngl_FragColor = vec4(h, 0.0, 0.0, 0.0);\n}"},THREE.ShaderLib.ocean_phase={uniforms:{u_phases:{type:"t",value:null},u_deltaTime:{type:"f",value:null},u_resolution:{type:"f",value:null},u_size:{type:"f",value:null}},varying:{vUV:{type:"v2"}},fragmentShader:"const float PI = 3.14159265359;\nconst float G = 9.81;\nconst float KM = 370.0;\nvarying vec2 vUV;\nuniform sampler2D u_phases;\nuniform float u_deltaTime;\nuniform float u_resolution;\nuniform float u_size;\nfloat omega (float k) {\nreturn sqrt(G * k * (1.0 + k * k / KM * KM));\n}\nvoid main (void) {\nvec2 coordinates = gl_FragCoord.xy - 0.5;\nfloat n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;\nfloat m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;\nvec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;\nfloat phase = texture2D(u_phases, vUV).r;\nfloat deltaPhase = omega(length(waveVector)) * u_deltaTime;\nphase = mod(phase + deltaPhase, 2.0 * PI);\ngl_FragColor = vec4(phase, 0.0, 0.0, 0.0);\n}"},THREE.ShaderLib.ocean_spectrum={uniforms:{u_size:{type:"f",value:null},u_resolution:{type:"f",value:null},u_choppiness:{type:"f",value:null},u_phases:{type:"t",value:null},u_initialSpectrum:{type:"t",value:null}},varying:{vUV:{type:"v2"}},fragmentShader:"const float PI = 3.14159265359;\nconst float G = 9.81;\nconst float KM = 370.0;\nvarying vec2 vUV;\nuniform float u_size;\nuniform float u_resolution;\nuniform float u_choppiness;\nuniform sampler2D u_phases;\nuniform sampler2D u_initialSpectrum;\nvec2 multiplyComplex (vec2 a, vec2 b) {\nreturn vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);\n}\nvec2 multiplyByI (vec2 z) {\nreturn vec2(-z[1], z[0]);\n}\nfloat omega (float k) {\nreturn sqrt(G * k * (1.0 + k * k / KM * KM));\n}\nvoid main (void) {\nvec2 coordinates = gl_FragCoord.xy - 0.5;\nfloat n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;\nfloat m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;\nvec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;\nfloat phase = texture2D(u_phases, vUV).r;\nvec2 phaseVector = vec2(cos(phase), sin(phase));\nvec2 h0 = texture2D(u_initialSpectrum, vUV).rg;\nvec2 h0Star = texture2D(u_initialSpectrum, vec2(1.0 - vUV + 1.0 / u_resolution)).rg;\nh0Star.y *= -1.0;\nvec2 h = multiplyComplex(h0, phaseVector) + multiplyComplex(h0Star, vec2(phaseVector.x, -phaseVector.y));\nvec2 hX = -multiplyByI(h * (waveVector.x / length(waveVector))) * u_choppiness;\nvec2 hZ = -multiplyByI(h * (waveVector.y / length(waveVector))) * u_choppiness;\nif (waveVector.x == 0.0 && waveVector.y == 0.0) {\nh = vec2(0.0);\nhX = vec2(0.0);\nhZ = vec2(0.0);\n}\ngl_FragColor = vec4(hX + multiplyByI(h), hZ);\n}"},THREE.ShaderLib.ocean_normals={uniforms:{u_displacementMap:{type:"t",value:null},u_resolution:{type:"f",value:null},u_size:{type:"f",value:null}},varying:{vUV:{type:"v2"}},fragmentShader:"varying vec2 vUV;\nuniform sampler2D u_displacementMap;\nuniform float u_resolution;\nuniform float u_size;\nvoid main (void) {\nfloat texel = 1.0 / u_resolution;\nfloat texelSize = u_size / u_resolution;\nvec3 center = texture2D(u_displacementMap, vUV).rgb;\nvec3 right = vec3(texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(texel, 0.0)).rgb - center;\nvec3 left = vec3(-texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(-texel, 0.0)).rgb - center;\nvec3 top = vec3(0.0, 0.0, -texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, -texel)).rgb - center;\nvec3 bottom = vec3(0.0, 0.0, texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, texel)).rgb - center;\nvec3 topRight = cross(right, top);\nvec3 topLeft = cross(top, left);\nvec3 bottomLeft = cross(left, bottom);\nvec3 bottomRight = cross(bottom, right);\ngl_FragColor = vec4(normalize(topRight + topLeft + bottomLeft + bottomRight), 1.0);\n}"},THREE.UniformsLib.oceanfft={u_displacementMap:{type:"t",value:null},u_reflection:{type:"t",value:null},u_normalMap:{type:"t",value:null},u_geometrySize:{type:"f",value:null},u_size:{type:"f",value:null},u_mirrorMatrix:{type:"m4",value:null},u_cameraPosition:{type:"v3",value:null},u_skyColor:{type:"v3",value:null},u_oceanColor:{type:"v3",value:null},u_sunDirection:{type:"v3",value:null},u_exposure:{type:"f",value:null}},THREE.ShaderChunk.oceanfft_pars_vertex="uniform sampler2D u_displacementMap;\nuniform float u_geometrySize;\nuniform float u_size;",THREE.ShaderChunk.oceanfft_vertex="vec3 displacement = texture2D( u_displacementMap, worldPosition.xz * 0.002 ).rgb * ( u_geometrySize / u_size );\nvec4 oceanfftWorldPosition = worldPosition + vec4( displacement, 0.0 );",THREE.ShaderChunk.oceanfft_pars_fragment="",THREE.ShaderChunk.oceanfft_fragment="";
//# sourceMappingURL=index.89a58267.js.map
