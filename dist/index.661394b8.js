THREE.ShaderChunk.screenplane_pars_vertex="const float infinite = 150000.0;\nconst float screenScale = 1.2;\nconst vec3 groundNormal = vec3( 0.0, 1.0, 0.0 );\nconst float groundHeight = 0.0;\nvarying vec3 vCamPosition;\nvec3 interceptPlane( in vec3 source, in vec3 dir, in vec3 normal, float height )\n{\n	float distance = ( - height - dot( normal, source ) ) / dot( normal, dir );\n	if( distance < 0.0 )\n		return source + dir * distance;\n	else \n		return - ( vec3( source.x, height, source.z ) + vec3( dir.x, height, dir.z ) * infinite );\n}\nmat3 getRotation()\n{\n	return mat3( \n		viewMatrix[0].xyz,\n		viewMatrix[1].xyz,\n		viewMatrix[2].xyz\n	);\n}\nvec3 getCameraPos( in mat3 rotation )\n{\n	return - viewMatrix[3].xyz * rotation;\n}\nvec2 getImagePlan()\n{\n	float focal = projectionMatrix[0].x;\n	float aspect = projectionMatrix[1].y;\n	return vec2( ( uv.x - 0.5 ) * screenScale * aspect, ( uv.y - 0.5 ) * screenScale * focal );\n}\nvec3 getCamRay( in mat3 rotation, in vec2 screenUV )\n{\n	return vec3( screenUV.x, screenUV.y, projectionMatrix[0].x ) * rotation;\n}\nvec3 computeProjectedPosition()\n{\n	mat3 cameraRotation = getRotation();\n	vec3 camPosition = getCameraPos( cameraRotation );\n	vCamPosition = camPosition;\n	if( camPosition.y < groundHeight )\n		return vec3( 0.0, 0.0, 0.0 );\n	vec2 screenUV = getImagePlan() ;\n	vec3 ray = getCamRay( cameraRotation, screenUV );\n	vec3 finalPos = interceptPlane( camPosition, ray, groundNormal, groundHeight );\n	float distance = length( finalPos );\n	if( distance > infinite )\n		finalPos *= infinite / distance;\n	return finalPos;\n}",THREE.ShaderChunk.screenplane_vertex="vec4 screenPlaneWorldPosition = vec4( computeProjectedPosition(), 1.0 );",THREE.ShaderChunk.screenplane_pars_fragment="varying vec3 vCamPosition;";
//# sourceMappingURL=index.661394b8.js.map
