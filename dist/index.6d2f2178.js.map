{"mappings":"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","sources":["<anon>","js/effects/Ocean.js"],"sourcesContent":["/**\n * @author jbouny / https://github.com/fft-ocean\n *\n * Based on:\n * @author Aleksandr Albert / http://www.routter.co.tt\n */ THREE.Ocean = function(renderer, camera, scene, options) {\n    // flag used to trigger parameter changes\n    this.changed = true;\n    this.initial = true;\n    // Assign required parameters as object properties\n    this.oceanCamera = new THREE.OrthographicCamera(); //camera.clone();\n    this.oceanCamera.position.z = 1;\n    this.renderer = renderer;\n    this.renderer.clearColor(0xffffff);\n    this.scene = new THREE.Scene();\n    // Enable necessary extensions\n    this.renderer.context.getExtension(\"OES_texture_float\");\n    this.renderer.context.getExtension(\"OES_texture_float_linear\");\n    // Create mirror rendering\n    this.mirror = new THREE.MirrorRenderer(renderer, camera, scene);\n    this.mirror.position.y = -10;\n    // Assign optional parameters as variables and object properties\n    function optionalParameter(value, defaultValue) {\n        return value !== undefined ? value : defaultValue;\n    }\n    function optionalParameterArray(value, index, defaultValue) {\n        return value !== undefined ? value[index] : defaultValue;\n    }\n    options = options || {};\n    this.sunDirection = optionalParameter(options.SUN_DIRECTION, new THREE.Vector3(-1, 1.0, 1.0));\n    this.oceanColor = optionalParameter(options.OCEAN_COLOR, new THREE.Vector3(0.004, 0.016, 0.047));\n    this.skyColor = optionalParameter(options.SKY_COLOR, new THREE.Vector3(3.2, 9.6, 12.8));\n    this.exposure = optionalParameter(options.EXPOSURE, 0.35);\n    this.geometryResolution = optionalParameter(options.GEOMETRY_RESOLUTION, 32);\n    this.geometrySize = optionalParameter(options.GEOMETRY_SIZE, 2000);\n    this.resolution = optionalParameter(options.RESOLUTION, 64);\n    this.floatSize = optionalParameter(options.SIZE_OF_FLOAT, 4);\n    this.windX = optionalParameterArray(options.INITIAL_WIND, 0, 10.0), this.windY = optionalParameterArray(options.INITIAL_WIND, 1, 10.0), this.size = optionalParameter(options.INITIAL_SIZE, 250.0), this.choppiness = optionalParameter(options.INITIAL_CHOPPINESS, 1.5);\n    this.matrixNeedsUpdate = false;\n    // Setup framebuffer pipeline\n    var BaseParams = {\n        format: THREE.RGBAFormat,\n        stencilBuffer: false,\n        depthBuffer: false,\n        premultiplyAlpha: false,\n        type: THREE.FloatType\n    };\n    var LinearClampParams = JSON.parse(JSON.stringify(BaseParams));\n    LinearClampParams.minFilter = LinearClampParams.magFilter = THREE.LinearFilter;\n    LinearClampParams.wrapS = LinearClampParams.wrapT = THREE.ClampToEdgeWrapping;\n    var NearestClampParams = JSON.parse(JSON.stringify(BaseParams));\n    NearestClampParams.minFilter = NearestClampParams.magFilter = THREE.NearestFilter;\n    NearestClampParams.wrapS = NearestClampParams.wrapT = THREE.ClampToEdgeWrapping;\n    var NearestRepeatParams = JSON.parse(JSON.stringify(BaseParams));\n    NearestRepeatParams.minFilter = NearestRepeatParams.magFilter = THREE.NearestFilter;\n    NearestRepeatParams.wrapS = NearestRepeatParams.wrapT = THREE.RepeatWrapping;\n    var LinearRepeatParams = JSON.parse(JSON.stringify(BaseParams));\n    LinearRepeatParams.minFilter = LinearRepeatParams.magFilter = THREE.LinearFilter;\n    LinearRepeatParams.wrapS = LinearRepeatParams.wrapT = THREE.RepeatWrapping;\n    this.initialSpectrumFramebuffer = new THREE.WebGLRenderTarget(this.resolution, this.resolution, NearestRepeatParams);\n    this.spectrumFramebuffer = new THREE.WebGLRenderTarget(this.resolution, this.resolution, NearestClampParams);\n    this.pingPhaseFramebuffer = new THREE.WebGLRenderTarget(this.resolution, this.resolution, NearestClampParams);\n    this.pongPhaseFramebuffer = new THREE.WebGLRenderTarget(this.resolution, this.resolution, NearestClampParams);\n    this.pingTransformFramebuffer = new THREE.WebGLRenderTarget(this.resolution, this.resolution, NearestClampParams);\n    this.pongTransformFramebuffer = new THREE.WebGLRenderTarget(this.resolution, this.resolution, NearestClampParams);\n    this.displacementMapFramebuffer = new THREE.WebGLRenderTarget(this.resolution, this.resolution, LinearRepeatParams);\n    this.normalMapFramebuffer = new THREE.WebGLRenderTarget(this.resolution, this.resolution, LinearRepeatParams);\n    // Define shaders and constant uniforms\n    ////////////////////////////////////////\n    // 0 - The vertex shader used in all of the simulation steps\n    var fullscreeenVertexShader = THREE.ShaderLib[\"ocean_sim_vertex\"];\n    // 1 - Horizontal wave vertices used for FFT\n    var oceanHorizontalShader = THREE.ShaderLib[\"ocean_subtransform\"];\n    var oceanHorizontalUniforms = THREE.UniformsUtils.clone(oceanHorizontalShader.uniforms);\n    this.materialOceanHorizontal = new THREE.ShaderMaterial({\n        uniforms: oceanHorizontalUniforms,\n        vertexShader: fullscreeenVertexShader.vertexShader,\n        fragmentShader: \"#define HORIZONTAL \\n\" + oceanHorizontalShader.fragmentShader\n    });\n    this.materialOceanHorizontal.uniforms.u_transformSize = {\n        type: \"f\",\n        value: this.resolution\n    };\n    this.materialOceanHorizontal.uniforms.u_subtransformSize = {\n        type: \"f\",\n        value: null\n    };\n    this.materialOceanHorizontal.uniforms.u_input = {\n        type: \"t\",\n        value: null\n    };\n    this.materialOceanHorizontal.depthTest = false;\n    // 2 - Vertical wave vertices used for FFT\n    var oceanVerticalShader = THREE.ShaderLib[\"ocean_subtransform\"];\n    var oceanVerticalUniforms = THREE.UniformsUtils.clone(oceanVerticalShader.uniforms);\n    this.materialOceanVertical = new THREE.ShaderMaterial({\n        uniforms: oceanVerticalUniforms,\n        vertexShader: fullscreeenVertexShader.vertexShader,\n        fragmentShader: oceanVerticalShader.fragmentShader\n    });\n    this.materialOceanVertical.uniforms.u_transformSize = {\n        type: \"f\",\n        value: this.resolution\n    };\n    this.materialOceanVertical.uniforms.u_subtransformSize = {\n        type: \"f\",\n        value: null\n    };\n    this.materialOceanVertical.uniforms.u_input = {\n        type: \"t\",\n        value: null\n    };\n    this.materialOceanVertical.depthTest = false;\n    // 3 - Initial spectrum used to generate height map\n    var initialSpectrumShader = THREE.ShaderLib[\"ocean_initial_spectrum\"];\n    var initialSpectrumUniforms = THREE.UniformsUtils.clone(initialSpectrumShader.uniforms);\n    this.materialInitialSpectrum = new THREE.ShaderMaterial({\n        uniforms: initialSpectrumUniforms,\n        vertexShader: fullscreeenVertexShader.vertexShader,\n        fragmentShader: initialSpectrumShader.fragmentShader\n    });\n    this.materialInitialSpectrum.uniforms.u_wind = {\n        type: \"v2\",\n        value: new THREE.Vector2()\n    };\n    this.materialInitialSpectrum.uniforms.u_resolution = {\n        type: \"f\",\n        value: this.resolution\n    };\n    this.materialInitialSpectrum.depthTest = false;\n    // 4 - Phases used to animate heightmap\n    var phaseShader = THREE.ShaderLib[\"ocean_phase\"];\n    var phaseUniforms = THREE.UniformsUtils.clone(phaseShader.uniforms);\n    this.materialPhase = new THREE.ShaderMaterial({\n        uniforms: phaseUniforms,\n        vertexShader: fullscreeenVertexShader.vertexShader,\n        fragmentShader: phaseShader.fragmentShader\n    });\n    this.materialPhase.uniforms.u_resolution = {\n        type: \"f\",\n        value: this.resolution\n    };\n    this.materialPhase.depthTest = false;\n    // 5 - Shader used to update spectrum\n    var spectrumShader = THREE.ShaderLib[\"ocean_spectrum\"];\n    var spectrumUniforms = THREE.UniformsUtils.clone(spectrumShader.uniforms);\n    this.materialSpectrum = new THREE.ShaderMaterial({\n        uniforms: spectrumUniforms,\n        vertexShader: fullscreeenVertexShader.vertexShader,\n        fragmentShader: spectrumShader.fragmentShader\n    });\n    this.materialSpectrum.uniforms.u_initialSpectrum = {\n        type: \"t\",\n        value: null\n    };\n    this.materialSpectrum.uniforms.u_resolution = {\n        type: \"f\",\n        value: this.resolution\n    };\n    this.materialSpectrum.uniforms.u_choppiness.value = this.choppiness;\n    this.materialSpectrum.depthTest = false;\n    // 6 - Shader used to update spectrum normals\n    var normalShader = THREE.ShaderLib[\"ocean_normals\"];\n    var normalUniforms = THREE.UniformsUtils.clone(normalShader.uniforms);\n    this.materialNormal = new THREE.ShaderMaterial({\n        uniforms: normalUniforms,\n        vertexShader: fullscreeenVertexShader.vertexShader,\n        fragmentShader: normalShader.fragmentShader\n    });\n    this.materialNormal.uniforms.u_displacementMap = {\n        type: \"t\",\n        value: null\n    };\n    this.materialNormal.uniforms.u_resolution = {\n        type: \"f\",\n        value: this.resolution\n    };\n    this.materialNormal.depthTest = false;\n    // 7 - Shader used to update normals\n    var oceanShader = THREE.ShaderLib[\"ocean_main\"];\n    var oceanUniforms = THREE.UniformsUtils.clone(oceanShader.uniforms);\n    var vertexShaderOcean = oceanShader.vertexShader;\n    var gl = renderer.getContext();\n    if (gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) === 0) vertexShaderOcean = oceanShader.vertexShaderNoTexLookup;\n    this.materialOcean = new THREE.ShaderMaterial({\n        uniforms: oceanUniforms,\n        vertexShader: vertexShaderOcean,\n        fragmentShader: oceanShader.fragmentShader,\n        side: THREE.FrontSide,\n        wireframe: false\n    });\n    //this.materialOcean.wireframe = true;\n    this.materialOcean.uniforms.u_geometrySize = {\n        type: \"f\",\n        value: this.resolution\n    };\n    this.materialOcean.uniforms.u_displacementMap = {\n        type: \"t\",\n        value: this.displacementMapFramebuffer\n    };\n    this.materialOcean.uniforms.u_reflection = {\n        type: \"t\",\n        value: this.mirror.texture\n    };\n    this.materialOcean.uniforms.u_mirrorMatrix = {\n        type: \"m4\",\n        value: this.mirror.textureMatrix\n    };\n    this.materialOcean.uniforms.u_normalMap = {\n        type: \"t\",\n        value: this.normalMapFramebuffer\n    };\n    this.materialOcean.uniforms.u_oceanColor = {\n        type: \"v3\",\n        value: this.oceanColor\n    };\n    this.materialOcean.uniforms.u_skyColor = {\n        type: \"v3\",\n        value: this.skyColor\n    };\n    this.materialOcean.uniforms.u_sunDirection = {\n        type: \"v3\",\n        value: this.sunDirection\n    };\n    this.materialOcean.uniforms.u_exposure = {\n        type: \"f\",\n        value: this.exposure\n    };\n    // Disable blending to prevent default premultiplied alpha values\n    this.materialOceanHorizontal.blending = 0;\n    this.materialOceanVertical.blending = 0;\n    this.materialInitialSpectrum.blending = 0;\n    this.materialPhase.blending = 0;\n    this.materialSpectrum.blending = 0;\n    this.materialNormal.blending = 0;\n    this.materialOcean.blending = 0;\n    // Create the simulation plane\n    this.screenQuad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2));\n    this.scene.add(this.screenQuad);\n    // Initialise spectrum data\n    this.generateSeedPhaseTexture();\n    // Generate the ocean mesh\n    this.generateMesh();\n    this.mirror.mesh = this.oceanMesh;\n    camera.add(this.oceanMesh);\n};\nTHREE.Ocean.prototype.generateMesh = function() {\n    var geometry = new THREE.PlaneBufferGeometry(1, 1, this.geometryResolution, this.geometryResolution);\n    this.oceanMesh = new THREE.Mesh(geometry, this.materialOcean);\n};\nTHREE.Ocean.prototype.update = function() {\n    this.overrideMaterial = this.materialOcean;\n    if (this.changed) {\n        this.materialOcean.uniforms.u_size.value = this.size;\n        this.materialOcean.uniforms.u_exposure.value = this.exposure;\n        this.changed = false;\n    }\n    this.materialOcean.uniforms.u_normalMap.value = this.normalMapFramebuffer;\n    this.materialOcean.uniforms.u_displacementMap.value = this.displacementMapFramebuffer;\n    this.materialOcean.depthTest = true;\n};\nTHREE.Ocean.prototype.render = function() {\n    this.scene.overrideMaterial = null;\n    if (this.changed) this.renderInitialSpectrum();\n    this.mirror.render();\n    this.renderWavePhase();\n    this.renderSpectrum();\n    this.renderSpectrumFFT();\n    this.renderNormalMap();\n    this.scene.overrideMaterial = null;\n};\nTHREE.Ocean.prototype.generateSeedPhaseTexture = function() {\n    // Setup the seed texture\n    this.pingPhase = true;\n    var phaseArray = new window.Float32Array(this.resolution * this.resolution * 4);\n    for(var i = 0; i < this.resolution; i++)for(var j = 0; j < this.resolution; j++){\n        phaseArray[i * this.resolution * 4 + j * 4] = Math.random() * 2.0 * Math.PI;\n        phaseArray[i * this.resolution * 4 + j * 4 + 1] = 0.0;\n        phaseArray[i * this.resolution * 4 + j * 4 + 2] = 0.0;\n        phaseArray[i * this.resolution * 4 + j * 4 + 3] = 0.0;\n    }\n    this.pingPhaseTexture = new THREE.DataTexture(phaseArray, this.resolution, this.resolution, THREE.RGBAFormat);\n    this.pingPhaseTexture.minFilter = THREE.NearestFilter;\n    this.pingPhaseTexture.magFilter = THREE.NearestFilter;\n    this.pingPhaseTexture.wrapS = THREE.ClampToEdgeWrapping;\n    this.pingPhaseTexture.wrapT = THREE.ClampToEdgeWrapping;\n    this.pingPhaseTexture.type = THREE.FloatType;\n    this.pingPhaseTexture.needsUpdate = true;\n};\nTHREE.Ocean.prototype.renderInitialSpectrum = function() {\n    this.scene.overrideMaterial = this.materialInitialSpectrum;\n    this.materialInitialSpectrum.uniforms.u_wind.value.set(this.windX, this.windY);\n    this.materialInitialSpectrum.uniforms.u_size.value = this.size;\n    this.renderer.render(this.scene, this.oceanCamera, this.initialSpectrumFramebuffer, true);\n};\nTHREE.Ocean.prototype.renderWavePhase = function() {\n    this.scene.overrideMaterial = this.materialPhase;\n    this.screenQuad.material = this.materialPhase;\n    if (this.initial) {\n        this.materialPhase.uniforms.u_phases.value = this.pingPhaseTexture;\n        this.initial = false;\n    } else this.materialPhase.uniforms.u_phases.value = this.pingPhase ? this.pingPhaseFramebuffer : this.pongPhaseFramebuffer;\n    this.materialPhase.uniforms.u_deltaTime.value = this.deltaTime;\n    this.materialPhase.uniforms.u_size.value = this.size;\n    this.renderer.render(this.scene, this.oceanCamera, this.pingPhase ? this.pongPhaseFramebuffer : this.pingPhaseFramebuffer);\n    this.pingPhase = !this.pingPhase;\n};\nTHREE.Ocean.prototype.renderSpectrum = function() {\n    this.scene.overrideMaterial = this.materialSpectrum;\n    this.materialSpectrum.uniforms.u_initialSpectrum.value = this.initialSpectrumFramebuffer;\n    this.materialSpectrum.uniforms.u_phases.value = this.pingPhase ? this.pingPhaseFramebuffer : this.pongPhaseFramebuffer;\n    //this.materialSpectrum.uniforms.u_choppiness.value = this.choppiness ;\n    this.materialSpectrum.uniforms.u_size.value = this.size;\n    this.renderer.render(this.scene, this.oceanCamera, this.spectrumFramebuffer);\n};\nTHREE.Ocean.prototype.renderSpectrumFFT = function() {\n    // GPU FFT using Stockham formulation\n    var iterations = Math.log2(this.resolution) * 2; // log2\n    this.scene.overrideMaterial = this.materialOceanHorizontal;\n    var subtransformProgram = this.materialOceanHorizontal;\n    // Processus 0-N\n    // material = materialOceanHorizontal\n    // 0 : material( spectrumFramebuffer ) > pingTransformFramebuffer\n    // i%2==0 : material( pongTransformFramebuffer ) > pingTransformFramebuffer\n    // i%2==1 : material( pingTransformFramebuffer ) > pongTransformFramebuffer\n    // i == N/2 : material = materialOceanVertical\n    // i%2==0 : material( pongTransformFramebuffer ) > pingTransformFramebuffer\n    // i%2==1 : material( pingTransformFramebuffer ) > pongTransformFramebuffer\n    // N-1 : materialOceanVertical( pingTransformFramebuffer / pongTransformFramebuffer ) > displacementMapFramebuffer\n    var frameBuffer;\n    var inputBuffer;\n    for(var i = 0; i < iterations; i++){\n        if (i === 0) {\n            inputBuffer = this.spectrumFramebuffer;\n            frameBuffer = this.pingTransformFramebuffer;\n        } else if (i === iterations - 1) {\n            inputBuffer = iterations % 2 === 0 ? this.pingTransformFramebuffer : this.pongTransformFramebuffer;\n            frameBuffer = this.displacementMapFramebuffer;\n        } else if (i % 2 === 1) {\n            inputBuffer = this.pingTransformFramebuffer;\n            frameBuffer = this.pongTransformFramebuffer;\n        } else {\n            inputBuffer = this.pongTransformFramebuffer;\n            frameBuffer = this.pingTransformFramebuffer;\n        }\n        if (i === iterations / 2) {\n            subtransformProgram = this.materialOceanVertical;\n            this.scene.overrideMaterial = this.materialOceanVertical;\n        }\n        subtransformProgram.uniforms.u_input.value = inputBuffer;\n        subtransformProgram.uniforms.u_subtransformSize.value = Math.pow(2, i % (iterations / 2) + 1);\n        this.renderer.render(this.scene, this.oceanCamera, frameBuffer);\n    }\n};\nTHREE.Ocean.prototype.renderNormalMap = function() {\n    this.scene.overrideMaterial = this.materialNormal;\n    if (this.changed) this.materialNormal.uniforms.u_size.value = this.size;\n    this.materialNormal.uniforms.u_displacementMap.value = this.displacementMapFramebuffer;\n    this.renderer.render(this.scene, this.oceanCamera, this.normalMapFramebuffer, true);\n};\n\n//# sourceMappingURL=index.6d2f2178.js.map\n","﻿/**\n * @author jbouny / https://github.com/fft-ocean\n *\n * Based on:\n * @author Aleksandr Albert / http://www.routter.co.tt\n */\n\nTHREE.Ocean = function (renderer, camera, scene, options) {\n\n\t// flag used to trigger parameter changes\n\tthis.changed = true;\n\tthis.initial = true;\n\t\n\t// Assign required parameters as object properties\n\tthis.oceanCamera = new THREE.OrthographicCamera(); //camera.clone();\n\tthis.oceanCamera.position.z = 1;\n\tthis.renderer = renderer;\n\tthis.renderer.clearColor( 0xffffff );\n\t\n\tthis.scene = new THREE.Scene();\n\t\n\t// Enable necessary extensions\n\tthis.renderer.context.getExtension('OES_texture_float');\n\tthis.renderer.context.getExtension('OES_texture_float_linear');\n\t\n\t// Create mirror rendering\n\tthis.mirror = new THREE.MirrorRenderer( renderer, camera, scene ) ;\n\tthis.mirror.position.y = -10.0;\n\t\n\t// Assign optional parameters as variables and object properties\n\tfunction optionalParameter(value, defaultValue) {\n\t\treturn value !== undefined ? value : defaultValue;\n\t};\n\tfunction optionalParameterArray(value, index, defaultValue) {\n\t\treturn value !== undefined ? value[index] : defaultValue;\n\t};\n\toptions = options || {};\n\tthis.sunDirection = optionalParameter(options.SUN_DIRECTION, new THREE.Vector3(-1.0, 1.0, 1.0 ));\n\tthis.oceanColor = optionalParameter(options.OCEAN_COLOR, new THREE.Vector3(0.004, 0.016, 0.047));\n\tthis.skyColor = optionalParameter(options.SKY_COLOR, new THREE.Vector3(3.2, 9.6, 12.8));\n\tthis.exposure = optionalParameter(options.EXPOSURE, 0.35);\n\tthis.geometryResolution = optionalParameter(options.GEOMETRY_RESOLUTION, 32);\n\tthis.geometrySize = optionalParameter(options.GEOMETRY_SIZE, 2000);\n\tthis.resolution = optionalParameter(options.RESOLUTION, 64);\n\tthis.floatSize = optionalParameter(options.SIZE_OF_FLOAT, 4);\n\tthis.windX = optionalParameterArray(options.INITIAL_WIND, 0, 10.0),\n\tthis.windY = optionalParameterArray(options.INITIAL_WIND, 1, 10.0),\n\tthis.size = optionalParameter(options.INITIAL_SIZE, 250.0),\n\tthis.choppiness = optionalParameter(options.INITIAL_CHOPPINESS, 1.5);\n\t\n\tthis.matrixNeedsUpdate = false;\n\t\n\t// Setup framebuffer pipeline\n\tvar BaseParams = {\n\t\tformat: THREE.RGBAFormat,\n\t\tstencilBuffer: false,\n\t\tdepthBuffer: false,\n\t\tpremultiplyAlpha: false,\n\t\ttype: THREE.FloatType\n\t};\n\tvar LinearClampParams = JSON.parse(JSON.stringify(BaseParams));\n\tLinearClampParams.minFilter = LinearClampParams.magFilter = THREE.LinearFilter ;\n\tLinearClampParams.wrapS = LinearClampParams.wrapT = THREE.ClampToEdgeWrapping ;\n\t\n\tvar NearestClampParams = JSON.parse(JSON.stringify(BaseParams));\n\tNearestClampParams.minFilter = NearestClampParams.magFilter = THREE.NearestFilter ;\n\tNearestClampParams.wrapS = NearestClampParams.wrapT = THREE.ClampToEdgeWrapping ;\n\t\n\tvar NearestRepeatParams = JSON.parse(JSON.stringify(BaseParams));\n\tNearestRepeatParams.minFilter = NearestRepeatParams.magFilter = THREE.NearestFilter ;\n\tNearestRepeatParams.wrapS = NearestRepeatParams.wrapT = THREE.RepeatWrapping ;\n\t\n\tvar LinearRepeatParams = JSON.parse(JSON.stringify(BaseParams));\n\tLinearRepeatParams.minFilter = LinearRepeatParams.magFilter = THREE.LinearFilter ;\n\tLinearRepeatParams.wrapS = LinearRepeatParams.wrapT = THREE.RepeatWrapping ;\n\t\n\tthis.initialSpectrumFramebuffer = new THREE.WebGLRenderTarget(this.resolution, this.resolution, NearestRepeatParams);\n\tthis.spectrumFramebuffer = new THREE.WebGLRenderTarget(this.resolution, this.resolution, NearestClampParams);\n\tthis.pingPhaseFramebuffer = new THREE.WebGLRenderTarget(this.resolution, this.resolution, NearestClampParams);\n\tthis.pongPhaseFramebuffer = new THREE.WebGLRenderTarget(this.resolution, this.resolution, NearestClampParams);\n\tthis.pingTransformFramebuffer = new THREE.WebGLRenderTarget(this.resolution, this.resolution, NearestClampParams);\n\tthis.pongTransformFramebuffer = new THREE.WebGLRenderTarget(this.resolution, this.resolution, NearestClampParams);\n\tthis.displacementMapFramebuffer = new THREE.WebGLRenderTarget(this.resolution, this.resolution, LinearRepeatParams);\n\tthis.normalMapFramebuffer = new THREE.WebGLRenderTarget(this.resolution, this.resolution, LinearRepeatParams);\n\t\n\t// Define shaders and constant uniforms\n\t////////////////////////////////////////\n\t\n\t// 0 - The vertex shader used in all of the simulation steps\n\tvar fullscreeenVertexShader = THREE.ShaderLib[\"ocean_sim_vertex\"];\n\t\t\n\t// 1 - Horizontal wave vertices used for FFT\n\tvar oceanHorizontalShader = THREE.ShaderLib[\"ocean_subtransform\"];\n\tvar oceanHorizontalUniforms = THREE.UniformsUtils.clone(oceanHorizontalShader.uniforms);\n\tthis.materialOceanHorizontal = new THREE.ShaderMaterial({\n\t\tuniforms: oceanHorizontalUniforms,\n\t\tvertexShader: fullscreeenVertexShader.vertexShader,\n\t\tfragmentShader: \"#define HORIZONTAL \\n\" + oceanHorizontalShader.fragmentShader\n\t});\n\tthis.materialOceanHorizontal.uniforms.u_transformSize = { type: \"f\", value: this.resolution };\n\tthis.materialOceanHorizontal.uniforms.u_subtransformSize = { type: \"f\", value: null };\n\tthis.materialOceanHorizontal.uniforms.u_input = { type: \"t\", value: null };\n\tthis.materialOceanHorizontal.depthTest = false;\n\t\n\t// 2 - Vertical wave vertices used for FFT\n\tvar oceanVerticalShader = THREE.ShaderLib[\"ocean_subtransform\"];\n\tvar oceanVerticalUniforms = THREE.UniformsUtils.clone(oceanVerticalShader.uniforms);\n\tthis.materialOceanVertical = new THREE.ShaderMaterial({\n\t\tuniforms: oceanVerticalUniforms,\n\t\tvertexShader: fullscreeenVertexShader.vertexShader,\n\t\tfragmentShader: oceanVerticalShader.fragmentShader\n\t});\n\tthis.materialOceanVertical.uniforms.u_transformSize = { type: \"f\", value: this.resolution };\n\tthis.materialOceanVertical.uniforms.u_subtransformSize = { type: \"f\", value: null };\n\tthis.materialOceanVertical.uniforms.u_input = { type: \"t\", value: null };\n\tthis.materialOceanVertical.depthTest = false;\n\t\n\t// 3 - Initial spectrum used to generate height map\n\tvar initialSpectrumShader = THREE.ShaderLib[\"ocean_initial_spectrum\"];\n\tvar initialSpectrumUniforms = THREE.UniformsUtils.clone(initialSpectrumShader.uniforms);\n\tthis.materialInitialSpectrum = new THREE.ShaderMaterial({\n\t\tuniforms: initialSpectrumUniforms,\n\t\tvertexShader: fullscreeenVertexShader.vertexShader,\n\t\tfragmentShader:initialSpectrumShader.fragmentShader\n\t});\n\tthis.materialInitialSpectrum.uniforms.u_wind = { type: \"v2\", value: new THREE.Vector2() };\n\tthis.materialInitialSpectrum.uniforms.u_resolution = { type: \"f\", value: this.resolution };\n\tthis.materialInitialSpectrum.depthTest = false;\n\t\n\t// 4 - Phases used to animate heightmap\n\tvar phaseShader = THREE.ShaderLib[\"ocean_phase\"];\n\tvar phaseUniforms = THREE.UniformsUtils.clone(phaseShader.uniforms);\n\tthis.materialPhase = new THREE.ShaderMaterial({\n\t\tuniforms: phaseUniforms,\n\t\tvertexShader: fullscreeenVertexShader.vertexShader,\n\t\tfragmentShader: phaseShader.fragmentShader\n\t});\n\tthis.materialPhase.uniforms.u_resolution = { type: \"f\", value: this.resolution };\n\tthis.materialPhase.depthTest = false;\n\t\n\t// 5 - Shader used to update spectrum\n\tvar spectrumShader = THREE.ShaderLib[\"ocean_spectrum\"];\n\tvar spectrumUniforms = THREE.UniformsUtils.clone(spectrumShader.uniforms);\n\tthis.materialSpectrum = new THREE.ShaderMaterial({\n\t\tuniforms: spectrumUniforms,\n\t\tvertexShader: fullscreeenVertexShader.vertexShader,\n\t\tfragmentShader: spectrumShader.fragmentShader\n\t});\n\tthis.materialSpectrum.uniforms.u_initialSpectrum = { type: \"t\", value: null };\n\tthis.materialSpectrum.uniforms.u_resolution = { type: \"f\", value: this.resolution };\n\tthis.materialSpectrum.uniforms.u_choppiness.value = this.choppiness ;\n\tthis.materialSpectrum.depthTest = false;\n\n\t// 6 - Shader used to update spectrum normals\n\tvar normalShader = THREE.ShaderLib[\"ocean_normals\"];\n\tvar normalUniforms = THREE.UniformsUtils.clone(normalShader.uniforms);\n\tthis.materialNormal = new THREE.ShaderMaterial({\n\t\tuniforms: normalUniforms,\n\t\tvertexShader: fullscreeenVertexShader.vertexShader,\n\t\tfragmentShader: normalShader.fragmentShader\n\t});\n\tthis.materialNormal.uniforms.u_displacementMap = { type: \"t\", value: null };\n\tthis.materialNormal.uniforms.u_resolution = { type: \"f\", value: this.resolution };\n\tthis.materialNormal.depthTest = false;\n\n\t// 7 - Shader used to update normals\n\tvar oceanShader = THREE.ShaderLib[\"ocean_main\"];\n\tvar oceanUniforms = THREE.UniformsUtils.clone(oceanShader.uniforms);\n\tvar vertexShaderOcean = oceanShader.vertexShader;\n\t{\n\t\tvar gl = renderer.getContext();\n\t\tif ( gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) === 0 ) {\n\t\t\tvertexShaderOcean = oceanShader.vertexShaderNoTexLookup;\n\t\t}\n\t}\n\tthis.materialOcean = new THREE.ShaderMaterial({\n\t\tuniforms: oceanUniforms,\n\t\tvertexShader: vertexShaderOcean,\n\t\tfragmentShader: oceanShader.fragmentShader,\n\t\tside: THREE.FrontSide,\n\t\twireframe: false\n\t});\n\t//this.materialOcean.wireframe = true;\n\tthis.materialOcean.uniforms.u_geometrySize = { type: \"f\", value: this.resolution };\n\tthis.materialOcean.uniforms.u_displacementMap = { type: \"t\", value: this.displacementMapFramebuffer };\n\tthis.materialOcean.uniforms.u_reflection = { type: \"t\", value: this.mirror.texture };\n\tthis.materialOcean.uniforms.u_mirrorMatrix = { type: \"m4\", value: this.mirror.textureMatrix };\n\tthis.materialOcean.uniforms.u_normalMap = { type: \"t\", value: this.normalMapFramebuffer }; \n\tthis.materialOcean.uniforms.u_oceanColor = { type: \"v3\", value: this.oceanColor }; \n\tthis.materialOcean.uniforms.u_skyColor = { type: \"v3\", value: this.skyColor };\n\tthis.materialOcean.uniforms.u_sunDirection = { type: \"v3\", value: this.sunDirection };\n\tthis.materialOcean.uniforms.u_exposure = { type: \"f\", value: this.exposure };\n\n\t// Disable blending to prevent default premultiplied alpha values\n\tthis.materialOceanHorizontal.blending = 0;\n\tthis.materialOceanVertical.blending = 0;\n\tthis.materialInitialSpectrum.blending = 0;\n\tthis.materialPhase.blending = 0;\n\tthis.materialSpectrum.blending = 0;\n\tthis.materialNormal.blending = 0;\n\tthis.materialOcean.blending = 0;\n\n\t// Create the simulation plane\n\tthis.screenQuad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ) );\n\tthis.scene.add(this.screenQuad);\n\n\t// Initialise spectrum data\n\tthis.generateSeedPhaseTexture();\n\n\t// Generate the ocean mesh\n\tthis.generateMesh();\n\tthis.mirror.mesh = this.oceanMesh;\n\tcamera.add( this.oceanMesh );\n\t\n};\n\nTHREE.Ocean.prototype.generateMesh = function () {\n\n\tvar geometry = new THREE.PlaneBufferGeometry( 1, 1, this.geometryResolution, this.geometryResolution );\n\tthis.oceanMesh = new THREE.Mesh( geometry, this.materialOcean );\n\t\n};\n\nTHREE.Ocean.prototype.update = function () {\n\n\tthis.overrideMaterial = this.materialOcean;\n\tif ( this.changed ) {\n\t\tthis.materialOcean.uniforms.u_size.value = this.size;\n\t\tthis.materialOcean.uniforms.u_exposure.value = this.exposure;\n\t\tthis.changed = false;\n\t}\n\tthis.materialOcean.uniforms.u_normalMap.value = this.normalMapFramebuffer ;\n\tthis.materialOcean.uniforms.u_displacementMap.value = this.displacementMapFramebuffer ;\n\tthis.materialOcean.depthTest = true;\n\t\n};\n\nTHREE.Ocean.prototype.render = function () {\n\n\tthis.scene.overrideMaterial = null;\n\t\n\tif (this.changed)\n\t\tthis.renderInitialSpectrum();\n\t\n\tthis.mirror.render();\n\tthis.renderWavePhase();\n\tthis.renderSpectrum();\n\tthis.renderSpectrumFFT();\n\tthis.renderNormalMap();\n\tthis.scene.overrideMaterial = null;\n\t\n};\n\nTHREE.Ocean.prototype.generateSeedPhaseTexture = function() {\n\n\t// Setup the seed texture\n\tthis.pingPhase = true;\n\tvar phaseArray = new window.Float32Array(this.resolution * this.resolution * 4);\n\tfor (var i = 0; i < this.resolution; i++) {\n\t\tfor (var j = 0; j < this.resolution; j++) {\n\t\t\tphaseArray[i * this.resolution * 4 + j * 4] = Math.random() * 2.0 * Math.PI;\n\t\t\tphaseArray[i * this.resolution * 4 + j * 4 + 1] = 0.0;\n\t\t\tphaseArray[i * this.resolution * 4 + j * 4 + 2] = 0.0;\n\t\t\tphaseArray[i * this.resolution * 4 + j * 4 + 3] = 0.0;\n\t\t}\n\t}\n\t\n\tthis.pingPhaseTexture = new THREE.DataTexture(phaseArray, this.resolution, this.resolution, THREE.RGBAFormat);\n\tthis.pingPhaseTexture.minFilter = THREE.NearestFilter;\n\tthis.pingPhaseTexture.magFilter = THREE.NearestFilter;\n\tthis.pingPhaseTexture.wrapS = THREE.ClampToEdgeWrapping;\n\tthis.pingPhaseTexture.wrapT = THREE.ClampToEdgeWrapping;\n\tthis.pingPhaseTexture.type = THREE.FloatType;\n\tthis.pingPhaseTexture.needsUpdate = true;\n\t\n};\n\nTHREE.Ocean.prototype.renderInitialSpectrum = function () {\n\n\tthis.scene.overrideMaterial = this.materialInitialSpectrum;\n\tthis.materialInitialSpectrum.uniforms.u_wind.value.set( this.windX, this.windY );\n\tthis.materialInitialSpectrum.uniforms.u_size.value = this.size;\n\tthis.renderer.render(this.scene, this.oceanCamera, this.initialSpectrumFramebuffer, true);\n\t\n};\n\nTHREE.Ocean.prototype.renderWavePhase = function () {\n\n\tthis.scene.overrideMaterial = this.materialPhase;\n\tthis.screenQuad.material = this.materialPhase;\n\tif (this.initial) {\n\t\tthis.materialPhase.uniforms.u_phases.value = this.pingPhaseTexture;\n\t\tthis.initial = false;\n\t}else {\n\t\tthis.materialPhase.uniforms.u_phases.value = this.pingPhase ? this.pingPhaseFramebuffer\t: this.pongPhaseFramebuffer;\n\t}\n\tthis.materialPhase.uniforms.u_deltaTime.value = this.deltaTime;\n\tthis.materialPhase.uniforms.u_size.value = this.size;\n\tthis.renderer.render(this.scene, this.oceanCamera, this.pingPhase ? this.pongPhaseFramebuffer : this.pingPhaseFramebuffer);\n\tthis.pingPhase = !this.pingPhase;\n\t\n};\n\nTHREE.Ocean.prototype.renderSpectrum = function () {\n\n\tthis.scene.overrideMaterial = this.materialSpectrum;\n\tthis.materialSpectrum.uniforms.u_initialSpectrum.value = this.initialSpectrumFramebuffer;\n\tthis.materialSpectrum.uniforms.u_phases.value = this.pingPhase ? this.pingPhaseFramebuffer : this.pongPhaseFramebuffer;\n\t//this.materialSpectrum.uniforms.u_choppiness.value = this.choppiness ;\n\tthis.materialSpectrum.uniforms.u_size.value = this.size ;\n\tthis.renderer.render(this.scene, this.oceanCamera, this.spectrumFramebuffer);\n\t\n};\n\nTHREE.Ocean.prototype.renderSpectrumFFT = function() {\n\n\t// GPU FFT using Stockham formulation\n\tvar iterations = Math.log2( this.resolution ) * 2; // log2\n\t\n\tthis.scene.overrideMaterial = this.materialOceanHorizontal;\n\tvar subtransformProgram = this.materialOceanHorizontal;\n\t\n\t// Processus 0-N\n\t// material = materialOceanHorizontal\n\t// 0 : material( spectrumFramebuffer ) > pingTransformFramebuffer\n\t\n\t// i%2==0 : material( pongTransformFramebuffer ) > pingTransformFramebuffer\n\t// i%2==1 : material( pingTransformFramebuffer ) > pongTransformFramebuffer\n\t\n\t// i == N/2 : material = materialOceanVertical\n\t\n\t// i%2==0 : material( pongTransformFramebuffer ) > pingTransformFramebuffer\n\t// i%2==1 : material( pingTransformFramebuffer ) > pongTransformFramebuffer\n\t\n\t// N-1 : materialOceanVertical( pingTransformFramebuffer / pongTransformFramebuffer ) > displacementMapFramebuffer\n\t\n\tvar frameBuffer;\n\tvar inputBuffer;\n\t\n\tfor (var i = 0; i < iterations; i++) {\n\t\tif (i === 0) {\n\t\t\tinputBuffer = this.spectrumFramebuffer;\n\t\t\tframeBuffer = this.pingTransformFramebuffer ;\n\t\t} \n\t\telse if (i === iterations - 1) {\n\t\t\tinputBuffer = ((iterations % 2 === 0)? this.pingTransformFramebuffer : this.pongTransformFramebuffer) ;\n\t\t\tframeBuffer = this.displacementMapFramebuffer ;\n\t\t}\n\t\telse if (i % 2 === 1) {\n\t\t\tinputBuffer = this.pingTransformFramebuffer;\n\t\t\tframeBuffer = this.pongTransformFramebuffer ;\n\t\t}\n\t\telse {\n\t\t\tinputBuffer = this.pongTransformFramebuffer;\n\t\t\tframeBuffer = this.pingTransformFramebuffer ;\n\t\t}\n\t\t\n\t\tif (i === iterations / 2) {\n\t\t\tsubtransformProgram = this.materialOceanVertical;\n\t\t\tthis.scene.overrideMaterial = this.materialOceanVertical;\n\t\t}\n\t\t\n\t\tsubtransformProgram.uniforms.u_input.value = inputBuffer;\n\t\t\n\t\tsubtransformProgram.uniforms.u_subtransformSize.value = Math.pow(2, (i % (iterations / 2) + 1 ));\n\t\tthis.renderer.render(this.scene, this.oceanCamera, frameBuffer);\n\t}\n\t\n};\n\nTHREE.Ocean.prototype.renderNormalMap = function () {\n\n\tthis.scene.overrideMaterial = this.materialNormal;\n\tif (this.changed) this.materialNormal.uniforms.u_size.value = this.size;\n\tthis.materialNormal.uniforms.u_displacementMap.value = this.displacementMapFramebuffer;\n\tthis.renderer.render(this.scene, this.oceanCamera, this.normalMapFramebuffer, true);\n\t\n};\n"],"names":["THREE","Ocean","renderer","camera","scene","options","optionalParameter","value","defaultValue","undefined","optionalParameterArray","index","changed","initial","oceanCamera","OrthographicCamera","position","z","clearColor","Scene","context","getExtension","mirror","MirrorRenderer","y","sunDirection","SUN_DIRECTION","Vector3","oceanColor","OCEAN_COLOR","skyColor","SKY_COLOR","exposure","EXPOSURE","geometryResolution","GEOMETRY_RESOLUTION","geometrySize","GEOMETRY_SIZE","resolution","RESOLUTION","floatSize","SIZE_OF_FLOAT","windX","INITIAL_WIND","windY","size","INITIAL_SIZE","choppiness","INITIAL_CHOPPINESS","matrixNeedsUpdate","BaseParams","format","RGBAFormat","stencilBuffer","depthBuffer","premultiplyAlpha","type","FloatType","LinearClampParams","JSON","parse","stringify","minFilter","magFilter","LinearFilter","wrapS","wrapT","ClampToEdgeWrapping","NearestClampParams","NearestFilter","NearestRepeatParams","RepeatWrapping","LinearRepeatParams","initialSpectrumFramebuffer","WebGLRenderTarget","spectrumFramebuffer","pingPhaseFramebuffer","pongPhaseFramebuffer","pingTransformFramebuffer","pongTransformFramebuffer","displacementMapFramebuffer","normalMapFramebuffer","fullscreeenVertexShader","ShaderLib","oceanHorizontalShader","oceanHorizontalUniforms","UniformsUtils","clone","uniforms","materialOceanHorizontal","ShaderMaterial","vertexShader","fragmentShader","u_transformSize","u_subtransformSize","u_input","depthTest","oceanVerticalShader","oceanVerticalUniforms","materialOceanVertical","initialSpectrumShader","initialSpectrumUniforms","materialInitialSpectrum","u_wind","Vector2","u_resolution","phaseShader","phaseUniforms","materialPhase","spectrumShader","spectrumUniforms","materialSpectrum","u_initialSpectrum","u_choppiness","normalShader","normalUniforms","materialNormal","u_displacementMap","oceanShader","oceanUniforms","vertexShaderOcean","gl","getContext","getParameter","MAX_VERTEX_TEXTURE_IMAGE_UNITS","vertexShaderNoTexLookup","materialOcean","side","FrontSide","wireframe","u_geometrySize","u_reflection","texture","u_mirrorMatrix","textureMatrix","u_normalMap","u_oceanColor","u_skyColor","u_sunDirection","u_exposure","blending","screenQuad","Mesh","PlaneBufferGeometry","add","generateSeedPhaseTexture","generateMesh","mesh","oceanMesh","prototype","geometry","update","overrideMaterial","u_size","render","renderInitialSpectrum","renderWavePhase","renderSpectrum","renderSpectrumFFT","renderNormalMap","pingPhase","phaseArray","window","Float32Array","i","j","Math","random","PI","pingPhaseTexture","DataTexture","needsUpdate","set","material","u_phases","u_deltaTime","deltaTime","frameBuffer","inputBuffer","iterations","log2","subtransformProgram","pow"],"version":3,"file":"index.6d2f2178.js.map"}