{"mappings":"ACmCA,MAAM,SAAS,CAAC,gBAAmB,CAAG,CACrC,QAAS,CACR,IAAO,CAAE,KAAM,IAAK,CACrB,EACA,aAAc,+GAQf,EACA,MAAM,SAAS,CAAC,kBAAqB,CAAG,CACvC,SAAU,CACT,QAAW,CAAE,KAAM,IAAK,MAAO,IAAK,EACpC,gBAAmB,CAAE,KAAM,IAAK,MAAO,GAAM,EAC7C,mBAAsB,CAAE,KAAM,IAAK,MAAO,GAAM,CACjD,EACA,QAAS,CACR,IAAO,CAAE,KAAM,IAAK,CACrB,EACA,eAAgB,mwCA0CjB,EACA,MAAM,SAAS,CAAC,sBAAyB,CAAG,CAC3C,SAAU,CACT,OAAU,CAAE,KAAM,KAAM,MAAO,IAAI,MAAM,OAAO,CAAC,GAAM,GAAM,EAC7D,aAAgB,CAAE,KAAM,IAAK,MAAO,GAAM,EAC1C,OAAU,CAAE,KAAM,IAAK,MAAO,GAAM,CACrC,EACA,eAAgB,y6DAwEjB,EACA,MAAM,SAAS,CAAC,WAAc,CAAG,CAChC,SAAU,CACT,SAAY,CAAE,KAAM,IAAK,MAAO,IAAK,EACrC,YAAe,CAAE,KAAM,IAAK,MAAO,IAAK,EACxC,aAAgB,CAAE,KAAM,IAAK,MAAO,IAAK,EACzC,OAAU,CAAE,KAAM,IAAK,MAAO,IAAK,CACpC,EACA,QAAS,CACR,IAAO,CAAE,KAAM,IAAK,CACrB,EACA,eAAgB,mxBA8BjB,EACA,MAAM,SAAS,CAAC,cAAiB,CAAG,CACnC,SAAU,CACT,OAAU,CAAE,KAAM,IAAK,MAAO,IAAK,EACnC,aAAgB,CAAE,KAAM,IAAK,MAAO,IAAK,EACzC,aAAgB,CAAE,KAAM,IAAK,MAAO,IAAK,EACzC,SAAY,CAAE,KAAM,IAAK,MAAO,IAAK,EACrC,kBAAqB,CAAE,KAAM,IAAK,MAAO,IAAK,CAC/C,EACA,QAAS,CACR,IAAO,CAAE,KAAM,IAAK,CACrB,EACA,eAAgB,g8CAsDjB,EACA,MAAM,SAAS,CAAC,aAAgB,CAAG,CAClC,SAAU,CACT,kBAAqB,CAAE,KAAM,IAAK,MAAO,IAAK,EAC9C,aAAgB,CAAE,KAAM,IAAK,MAAO,IAAK,EACzC,OAAU,CAAE,KAAM,IAAK,MAAO,IAAK,CACpC,EACA,QAAS,CACR,IAAO,CAAE,KAAM,IAAK,CACrB,EACA,eAAgB,06BA0BjB,EAEA,MAAM,WAAW,CAAE,QAAY,CAAG,CAEjC,kBAAqB,CAAE,KAAM,IAAK,MAAO,IAAK,EAC9C,aAAgB,CAAE,KAAM,IAAK,MAAO,IAAK,EACzC,YAAe,CAAE,KAAM,IAAK,MAAO,IAAK,EACxC,eAAkB,CAAE,KAAM,IAAK,MAAO,IAAK,EAC3C,OAAU,CAAE,KAAM,IAAK,MAAO,IAAK,EACnC,eAAkB,CAAE,KAAM,KAAM,MAAO,IAAK,EAC5C,iBAAoB,CAAE,KAAM,KAAM,MAAO,IAAK,EAC9C,WAAc,CAAE,KAAM,KAAM,MAAO,IAAK,EACxC,aAAgB,CAAE,KAAM,KAAM,MAAO,IAAK,EAC1C,eAAkB,CAAE,KAAM,KAAM,MAAO,IAAK,EAC5C,WAAc,CAAE,KAAM,IAAK,MAAO,IAAK,CAExC,EAEA,MAAM,WAAW,CAAE,oBAAwB,CAAG,6FAQ9C,MAAM,WAAW,CAAE,eAAmB,CAAG,2LAOzC,MAAM,WAAW,CAAE,sBAA0B,CAAG,GAIhD,MAAM,WAAW,CAAE,iBAAqB,CAAG","sources":["<anon>","js/shaders/FFTOceanShader.js"],"sourcesContent":["/**\n * Original work:\n * @author David Li / http://david.li/waves/\n *\n * Three.js version:\n * @author Aleksandr Albert / http://www.routter.co.tt\n * \n * Modified:\n * @author jbouny / https://github.com/fft-ocean\n */ // Author: Aleksandr Albert\n// Website: www.routter.co.tt\n// Description: A deep water ocean shader set\n// based on an implementation of a Tessendorf Waves\n// originally presented by David Li ( www.david.li/waves )\n// The general method is to apply shaders to simulation Framebuffers\n// and then sample these framebuffers when rendering the ocean mesh\n// The set uses 7 shaders:\n// -- Simulation shaders\n// [1] ocean_sim_vertex         -> Vertex shader used to set up a 2x2 simulation plane centered at (0,0)\n// [2] ocean_subtransform       -> Fragment shader used to subtransform the mesh (generates the displacement map)\n// [3] ocean_initial_spectrum   -> Fragment shader used to set intitial wave frequency at a texel coordinate\n// [4] ocean_phase              -> Fragment shader used to set wave phase at a texel coordinate\n// [5] ocean_spectrum           -> Fragment shader used to set current wave frequency at a texel coordinate\n// [6] ocean_normal             -> Fragment shader used to set face normals at a texel coordinate\n// -- Rendering Shader\n// [7] ocean_main               -> Vertex and Fragment shader used to create the final render\nTHREE.ShaderLib[\"ocean_sim_vertex\"] = {\n    varying: {\n        \"vUV\": {\n            type: \"v2\"\n        }\n    },\n    vertexShader: [\n        \"varying vec2 vUV;\",\n        \"void main (void) {\",\n        \"vUV = position.xy * 0.5 + 0.5;\",\n        \"gl_Position = vec4(position, 1.0 );\",\n        \"}\"\n    ].join(\"\\n\")\n};\nTHREE.ShaderLib[\"ocean_subtransform\"] = {\n    uniforms: {\n        \"u_input\": {\n            type: \"t\",\n            value: null\n        },\n        \"u_transformSize\": {\n            type: \"f\",\n            value: 512.0\n        },\n        \"u_subtransformSize\": {\n            type: \"f\",\n            value: 250.0\n        }\n    },\n    varying: {\n        \"vUV\": {\n            type: \"v2\"\n        }\n    },\n    fragmentShader: [\n        //GPU FFT using a Stockham formulation\n        \"const float PI = 3.14159265359;\",\n        \"uniform sampler2D u_input;\",\n        \"uniform float u_transformSize;\",\n        \"uniform float u_subtransformSize;\",\n        \"varying vec2 vUV;\",\n        \"vec2 multiplyComplex (vec2 a, vec2 b) {\",\n        \"return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);\",\n        \"}\",\n        \"void main (void) {\",\n        \"#ifdef HORIZONTAL\",\n        \"float index = vUV.x * u_transformSize - 0.5;\",\n        \"#else\",\n        \"float index = vUV.y * u_transformSize - 0.5;\",\n        \"#endif\",\n        \"float evenIndex = floor(index / u_subtransformSize) * (u_subtransformSize * 0.5) + mod(index, u_subtransformSize * 0.5);\",\n        //transform two complex sequences simultaneously\n        \"#ifdef HORIZONTAL\",\n        \"vec4 even = texture2D(u_input, vec2(evenIndex + 0.5, gl_FragCoord.y) / u_transformSize).rgba;\",\n        \"vec4 odd = texture2D(u_input, vec2(evenIndex + u_transformSize * 0.5 + 0.5, gl_FragCoord.y) / u_transformSize).rgba;\",\n        \"#else\",\n        \"vec4 even = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + 0.5) / u_transformSize).rgba;\",\n        \"vec4 odd = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + u_transformSize * 0.5 + 0.5) / u_transformSize).rgba;\",\n        \"#endif\",\n        \"float twiddleArgument = -2.0 * PI * (index / u_subtransformSize);\",\n        \"vec2 twiddle = vec2(cos(twiddleArgument), sin(twiddleArgument));\",\n        \"vec2 outputA = even.xy + multiplyComplex(twiddle, odd.xy);\",\n        \"vec2 outputB = even.zw + multiplyComplex(twiddle, odd.zw);\",\n        \"gl_FragColor = vec4(outputA, outputB);\",\n        \"}\"\n    ].join(\"\\n\")\n};\nTHREE.ShaderLib[\"ocean_initial_spectrum\"] = {\n    uniforms: {\n        \"u_wind\": {\n            type: \"v2\",\n            value: new THREE.Vector2(10.0, 10.0)\n        },\n        \"u_resolution\": {\n            type: \"f\",\n            value: 512.0\n        },\n        \"u_size\": {\n            type: \"f\",\n            value: 250.0\n        }\n    },\n    fragmentShader: [\n        \"const float PI = 3.14159265359;\",\n        \"const float G = 9.81;\",\n        \"const float KM = 370.0;\",\n        \"const float CM = 0.23;\",\n        \"uniform vec2 u_wind;\",\n        \"uniform float u_resolution;\",\n        \"uniform float u_size;\",\n        \"float square (float x) {\",\n        \"return x * x;\",\n        \"}\",\n        \"float omega (float k) {\",\n        \"return sqrt(G * k * (1.0 + square(k / KM)));\",\n        \"}\",\n        \"float tanh (float x) {\",\n        \"return (1.0 - exp(-2.0 * x)) / (1.0 + exp(-2.0 * x));\",\n        \"}\",\n        \"void main (void) {\",\n        \"vec2 coordinates = gl_FragCoord.xy - 0.5;\",\n        \"float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;\",\n        \"float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;\",\n        \"vec2 K = (2.0 * PI * vec2(n, m)) / u_size;\",\n        \"float k = length(K);\",\n        \"float l_wind = length(u_wind);\",\n        \"float Omega = 0.84;\",\n        \"float kp = G * square(Omega / l_wind);\",\n        \"float c = omega(k) / k;\",\n        \"float cp = omega(kp) / kp;\",\n        \"float Lpm = exp(-1.25 * square(kp / k));\",\n        \"float gamma = 1.7;\",\n        \"float sigma = 0.08 * (1.0 + 4.0 * pow(Omega, -3.0));\",\n        \"float Gamma = exp(-square(sqrt(k / kp) - 1.0) / 2.0 * square(sigma));\",\n        \"float Jp = pow(gamma, Gamma);\",\n        \"float Fp = Lpm * Jp * exp(-Omega / sqrt(10.0) * (sqrt(k / kp) - 1.0));\",\n        \"float alphap = 0.006 * sqrt(Omega);\",\n        \"float Bl = 0.5 * alphap * cp / c * Fp;\",\n        \"float z0 = 0.000037 * square(l_wind) / G * pow(l_wind / cp, 0.9);\",\n        \"float uStar = 0.41 * l_wind / log(10.0 / z0);\",\n        \"float alpham = 0.01 * ((uStar < CM) ? (1.0 + log(uStar / CM)) : (1.0 + 3.0 * log(uStar / CM)));\",\n        \"float Fm = exp(-0.25 * square(k / KM - 1.0));\",\n        \"float Bh = 0.5 * alpham * CM / c * Fm * Lpm;\",\n        \"float a0 = log(2.0) / 4.0;\",\n        \"float am = 0.13 * uStar / CM;\",\n        \"float Delta = tanh(a0 + 4.0 * pow(c / cp, 2.5) + am * pow(CM / c, 2.5));\",\n        \"float cosPhi = dot(normalize(u_wind), normalize(K));\",\n        \"float S = (1.0 / (2.0 * PI)) * pow(k, -4.0) * (Bl + Bh) * (1.0 + Delta * (2.0 * cosPhi * cosPhi - 1.0));\",\n        \"float dk = 2.0 * PI / u_size;\",\n        \"float h = sqrt(S / 2.0) * dk;\",\n        \"if (K.x == 0.0 && K.y == 0.0) {\",\n        \"h = 0.0;\",\n        \"}\",\n        \"gl_FragColor = vec4(h, 0.0, 0.0, 0.0);\",\n        \"}\"\n    ].join(\"\\n\")\n};\nTHREE.ShaderLib[\"ocean_phase\"] = {\n    uniforms: {\n        \"u_phases\": {\n            type: \"t\",\n            value: null\n        },\n        \"u_deltaTime\": {\n            type: \"f\",\n            value: null\n        },\n        \"u_resolution\": {\n            type: \"f\",\n            value: null\n        },\n        \"u_size\": {\n            type: \"f\",\n            value: null\n        }\n    },\n    varying: {\n        \"vUV\": {\n            type: \"v2\"\n        }\n    },\n    fragmentShader: [\n        \"const float PI = 3.14159265359;\",\n        \"const float G = 9.81;\",\n        \"const float KM = 370.0;\",\n        \"varying vec2 vUV;\",\n        \"uniform sampler2D u_phases;\",\n        \"uniform float u_deltaTime;\",\n        \"uniform float u_resolution;\",\n        \"uniform float u_size;\",\n        \"float omega (float k) {\",\n        \"return sqrt(G * k * (1.0 + k * k / KM * KM));\",\n        \"}\",\n        \"void main (void) {\",\n        \"vec2 coordinates = gl_FragCoord.xy - 0.5;\",\n        \"float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;\",\n        \"float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;\",\n        \"vec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;\",\n        \"float phase = texture2D(u_phases, vUV).r;\",\n        \"float deltaPhase = omega(length(waveVector)) * u_deltaTime;\",\n        \"phase = mod(phase + deltaPhase, 2.0 * PI);\",\n        \"gl_FragColor = vec4(phase, 0.0, 0.0, 0.0);\",\n        \"}\"\n    ].join(\"\\n\")\n};\nTHREE.ShaderLib[\"ocean_spectrum\"] = {\n    uniforms: {\n        \"u_size\": {\n            type: \"f\",\n            value: null\n        },\n        \"u_resolution\": {\n            type: \"f\",\n            value: null\n        },\n        \"u_choppiness\": {\n            type: \"f\",\n            value: null\n        },\n        \"u_phases\": {\n            type: \"t\",\n            value: null\n        },\n        \"u_initialSpectrum\": {\n            type: \"t\",\n            value: null\n        }\n    },\n    varying: {\n        \"vUV\": {\n            type: \"v2\"\n        }\n    },\n    fragmentShader: [\n        \"const float PI = 3.14159265359;\",\n        \"const float G = 9.81;\",\n        \"const float KM = 370.0;\",\n        \"varying vec2 vUV;\",\n        \"uniform float u_size;\",\n        \"uniform float u_resolution;\",\n        \"uniform float u_choppiness;\",\n        \"uniform sampler2D u_phases;\",\n        \"uniform sampler2D u_initialSpectrum;\",\n        \"vec2 multiplyComplex (vec2 a, vec2 b) {\",\n        \"return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);\",\n        \"}\",\n        \"vec2 multiplyByI (vec2 z) {\",\n        \"return vec2(-z[1], z[0]);\",\n        \"}\",\n        \"float omega (float k) {\",\n        \"return sqrt(G * k * (1.0 + k * k / KM * KM));\",\n        \"}\",\n        \"void main (void) {\",\n        \"vec2 coordinates = gl_FragCoord.xy - 0.5;\",\n        \"float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;\",\n        \"float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;\",\n        \"vec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;\",\n        \"float phase = texture2D(u_phases, vUV).r;\",\n        \"vec2 phaseVector = vec2(cos(phase), sin(phase));\",\n        \"vec2 h0 = texture2D(u_initialSpectrum, vUV).rg;\",\n        \"vec2 h0Star = texture2D(u_initialSpectrum, vec2(1.0 - vUV + 1.0 / u_resolution)).rg;\",\n        \"h0Star.y *= -1.0;\",\n        \"vec2 h = multiplyComplex(h0, phaseVector) + multiplyComplex(h0Star, vec2(phaseVector.x, -phaseVector.y));\",\n        \"vec2 hX = -multiplyByI(h * (waveVector.x / length(waveVector))) * u_choppiness;\",\n        \"vec2 hZ = -multiplyByI(h * (waveVector.y / length(waveVector))) * u_choppiness;\",\n        //no DC term\n        \"if (waveVector.x == 0.0 && waveVector.y == 0.0) {\",\n        \"h = vec2(0.0);\",\n        \"hX = vec2(0.0);\",\n        \"hZ = vec2(0.0);\",\n        \"}\",\n        \"gl_FragColor = vec4(hX + multiplyByI(h), hZ);\",\n        \"}\"\n    ].join(\"\\n\")\n};\nTHREE.ShaderLib[\"ocean_normals\"] = {\n    uniforms: {\n        \"u_displacementMap\": {\n            type: \"t\",\n            value: null\n        },\n        \"u_resolution\": {\n            type: \"f\",\n            value: null\n        },\n        \"u_size\": {\n            type: \"f\",\n            value: null\n        }\n    },\n    varying: {\n        \"vUV\": {\n            type: \"v2\"\n        }\n    },\n    fragmentShader: [\n        \"varying vec2 vUV;\",\n        \"uniform sampler2D u_displacementMap;\",\n        \"uniform float u_resolution;\",\n        \"uniform float u_size;\",\n        \"void main (void) {\",\n        \"float texel = 1.0 / u_resolution;\",\n        \"float texelSize = u_size / u_resolution;\",\n        \"vec3 center = texture2D(u_displacementMap, vUV).rgb;\",\n        \"vec3 right = vec3(texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(texel, 0.0)).rgb - center;\",\n        \"vec3 left = vec3(-texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(-texel, 0.0)).rgb - center;\",\n        \"vec3 top = vec3(0.0, 0.0, -texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, -texel)).rgb - center;\",\n        \"vec3 bottom = vec3(0.0, 0.0, texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, texel)).rgb - center;\",\n        \"vec3 topRight = cross(right, top);\",\n        \"vec3 topLeft = cross(top, left);\",\n        \"vec3 bottomLeft = cross(left, bottom);\",\n        \"vec3 bottomRight = cross(bottom, right);\",\n        \"gl_FragColor = vec4(normalize(topRight + topLeft + bottomLeft + bottomRight), 1.0);\",\n        \"}\"\n    ].join(\"\\n\")\n};\nTHREE.UniformsLib[\"oceanfft\"] = {\n    \"u_displacementMap\": {\n        type: \"t\",\n        value: null\n    },\n    \"u_reflection\": {\n        type: \"t\",\n        value: null\n    },\n    \"u_normalMap\": {\n        type: \"t\",\n        value: null\n    },\n    \"u_geometrySize\": {\n        type: \"f\",\n        value: null\n    },\n    \"u_size\": {\n        type: \"f\",\n        value: null\n    },\n    \"u_mirrorMatrix\": {\n        type: \"m4\",\n        value: null\n    },\n    \"u_cameraPosition\": {\n        type: \"v3\",\n        value: null\n    },\n    \"u_skyColor\": {\n        type: \"v3\",\n        value: null\n    },\n    \"u_oceanColor\": {\n        type: \"v3\",\n        value: null\n    },\n    \"u_sunDirection\": {\n        type: \"v3\",\n        value: null\n    },\n    \"u_exposure\": {\n        type: \"f\",\n        value: null\n    }\n}, THREE.ShaderChunk[\"oceanfft_pars_vertex\"] = [\n    \"uniform sampler2D u_displacementMap;\",\n    \"uniform float u_geometrySize;\",\n    \"uniform float u_size;\"\n].join(\"\\n\");\nTHREE.ShaderChunk[\"oceanfft_vertex\"] = [\n    \"vec3 displacement = texture2D( u_displacementMap, worldPosition.xz * 0.002 ).rgb * ( u_geometrySize / u_size );\",\n    \"vec4 oceanfftWorldPosition = worldPosition + vec4( displacement, 0.0 );\"\n].join(\"\\n\");\nTHREE.ShaderChunk[\"oceanfft_pars_fragment\"] = [].join(\"\\n\");\nTHREE.ShaderChunk[\"oceanfft_fragment\"] = [].join(\"\\n\");\n\n//# sourceMappingURL=index.89a58267.js.map\n","﻿/**\n * Original work:\n * @author David Li / http://david.li/waves/\n *\n * Three.js version:\n * @author Aleksandr Albert / http://www.routter.co.tt\n * \n * Modified:\n * @author jbouny / https://github.com/fft-ocean\n */\n \n// Author: Aleksandr Albert\n// Website: www.routter.co.tt\n\n// Description: A deep water ocean shader set\n// based on an implementation of a Tessendorf Waves\n// originally presented by David Li ( www.david.li/waves )\n\n// The general method is to apply shaders to simulation Framebuffers\n// and then sample these framebuffers when rendering the ocean mesh\n\n// The set uses 7 shaders:\n\n// -- Simulation shaders\n// [1] ocean_sim_vertex         -> Vertex shader used to set up a 2x2 simulation plane centered at (0,0)\n// [2] ocean_subtransform       -> Fragment shader used to subtransform the mesh (generates the displacement map)\n// [3] ocean_initial_spectrum   -> Fragment shader used to set intitial wave frequency at a texel coordinate\n// [4] ocean_phase              -> Fragment shader used to set wave phase at a texel coordinate\n// [5] ocean_spectrum           -> Fragment shader used to set current wave frequency at a texel coordinate\n// [6] ocean_normal             -> Fragment shader used to set face normals at a texel coordinate\n\n// -- Rendering Shader\n// [7] ocean_main               -> Vertex and Fragment shader used to create the final render\n\n\nTHREE.ShaderLib['ocean_sim_vertex'] = {\n\tvarying: {\n\t\t\"vUV\": { type: \"v2\" }\n\t},\n\tvertexShader: [\n\t\t'varying vec2 vUV;',\n\n\t\t'void main (void) {',\n\t\t\t'vUV = position.xy * 0.5 + 0.5;',\n\t\t\t'gl_Position = vec4(position, 1.0 );',\n\t\t'}'\n\t].join('\\n')\n};\nTHREE.ShaderLib['ocean_subtransform'] = {\n\tuniforms: {\n\t\t\"u_input\": { type: \"t\", value: null },\n\t\t\"u_transformSize\": { type: \"f\", value: 512.0 },\n\t\t\"u_subtransformSize\": { type: \"f\", value: 250.0 }\n\t},\n\tvarying: {\n\t\t\"vUV\": { type: \"v2\" }\n\t},\n\tfragmentShader: [\n\t\t//GPU FFT using a Stockham formulation\n\n\t\t'const float PI = 3.14159265359;',\n\n\t\t'uniform sampler2D u_input;',\n\t\t'uniform float u_transformSize;',\n\t\t'uniform float u_subtransformSize;',\n\n\t\t'varying vec2 vUV;',\n\t\t\n\t\t'vec2 multiplyComplex (vec2 a, vec2 b) {',\n\t\t\t'return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);',\n\t\t'}',\n\n\t\t'void main (void) {',\n\t\t\t'#ifdef HORIZONTAL',\n\t\t\t\t'float index = vUV.x * u_transformSize - 0.5;',\n\t\t\t'#else',\n\t\t\t\t'float index = vUV.y * u_transformSize - 0.5;',\n\t\t\t'#endif',\n\n\t\t\t'float evenIndex = floor(index / u_subtransformSize) * (u_subtransformSize * 0.5) + mod(index, u_subtransformSize * 0.5);',\n\n\t\t\t//transform two complex sequences simultaneously\n\t\t\t'#ifdef HORIZONTAL',\n\t\t\t\t'vec4 even = texture2D(u_input, vec2(evenIndex + 0.5, gl_FragCoord.y) / u_transformSize).rgba;',\n\t\t\t\t'vec4 odd = texture2D(u_input, vec2(evenIndex + u_transformSize * 0.5 + 0.5, gl_FragCoord.y) / u_transformSize).rgba;',\n\t\t\t'#else',\n\t\t\t\t'vec4 even = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + 0.5) / u_transformSize).rgba;',\n\t\t\t\t'vec4 odd = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + u_transformSize * 0.5 + 0.5) / u_transformSize).rgba;',\n\t\t\t'#endif',\n\n\t\t\t'float twiddleArgument = -2.0 * PI * (index / u_subtransformSize);',\n\t\t\t'vec2 twiddle = vec2(cos(twiddleArgument), sin(twiddleArgument));',\n\n\t\t\t'vec2 outputA = even.xy + multiplyComplex(twiddle, odd.xy);',\n\t\t\t'vec2 outputB = even.zw + multiplyComplex(twiddle, odd.zw);',\n\n\t\t\t'gl_FragColor = vec4(outputA, outputB);',\n\t\t'}'\n\t].join('\\n')\n};\nTHREE.ShaderLib['ocean_initial_spectrum'] = {\n\tuniforms: {\n\t\t\"u_wind\": { type: \"v2\", value: new THREE.Vector2(10.0, 10.0) },\n\t\t\"u_resolution\": { type: \"f\", value: 512.0 },\n\t\t\"u_size\": { type: \"f\", value: 250.0 },\n\t},\n\tfragmentShader: [\n\n\t\t'const float PI = 3.14159265359;',\n\t\t'const float G = 9.81;',\n\t\t'const float KM = 370.0;',\n\t\t'const float CM = 0.23;',\n\n\t\t'uniform vec2 u_wind;',\n\t\t'uniform float u_resolution;',\n\t\t'uniform float u_size;',\n\t\t\n\t\t'float square (float x) {',\n\t\t\t'return x * x;',\n\t\t'}',\n\n\t\t'float omega (float k) {',\n\t\t\t'return sqrt(G * k * (1.0 + square(k / KM)));',\n\t\t'}',\n\n\t\t'float tanh (float x) {',\n\t\t\t'return (1.0 - exp(-2.0 * x)) / (1.0 + exp(-2.0 * x));',\n\t\t'}',\n\n\t\t'void main (void) {',\n\t\t\t'vec2 coordinates = gl_FragCoord.xy - 0.5;',\n\t\t\t\n\t\t\t'float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;',\n\t\t\t'float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;',\n\t\t\t\n\t\t\t'vec2 K = (2.0 * PI * vec2(n, m)) / u_size;',\n\t\t\t'float k = length(K);',\n\t\t\t\n\t\t\t'float l_wind = length(u_wind);',\n\n\t\t\t'float Omega = 0.84;',\n\t\t\t'float kp = G * square(Omega / l_wind);',\n\n\t\t\t'float c = omega(k) / k;',\n\t\t\t'float cp = omega(kp) / kp;',\n\n\t\t\t'float Lpm = exp(-1.25 * square(kp / k));',\n\t\t\t'float gamma = 1.7;',\n\t\t\t'float sigma = 0.08 * (1.0 + 4.0 * pow(Omega, -3.0));',\n\t\t\t'float Gamma = exp(-square(sqrt(k / kp) - 1.0) / 2.0 * square(sigma));',\n\t\t\t'float Jp = pow(gamma, Gamma);',\n\t\t\t'float Fp = Lpm * Jp * exp(-Omega / sqrt(10.0) * (sqrt(k / kp) - 1.0));',\n\t\t\t'float alphap = 0.006 * sqrt(Omega);',\n\t\t\t'float Bl = 0.5 * alphap * cp / c * Fp;',\n\n\t\t\t'float z0 = 0.000037 * square(l_wind) / G * pow(l_wind / cp, 0.9);',\n\t\t\t'float uStar = 0.41 * l_wind / log(10.0 / z0);',\n\t\t\t'float alpham = 0.01 * ((uStar < CM) ? (1.0 + log(uStar / CM)) : (1.0 + 3.0 * log(uStar / CM)));',\n\t\t\t'float Fm = exp(-0.25 * square(k / KM - 1.0));',\n\t\t\t'float Bh = 0.5 * alpham * CM / c * Fm * Lpm;',\n\n\t\t\t'float a0 = log(2.0) / 4.0;',\n\t\t\t'float am = 0.13 * uStar / CM;',\n\t\t\t'float Delta = tanh(a0 + 4.0 * pow(c / cp, 2.5) + am * pow(CM / c, 2.5));',\n\n\t\t\t'float cosPhi = dot(normalize(u_wind), normalize(K));',\n\n\t\t\t'float S = (1.0 / (2.0 * PI)) * pow(k, -4.0) * (Bl + Bh) * (1.0 + Delta * (2.0 * cosPhi * cosPhi - 1.0));',\n\n\t\t\t'float dk = 2.0 * PI / u_size;',\n\t\t\t'float h = sqrt(S / 2.0) * dk;',\n\n\t\t\t'if (K.x == 0.0 && K.y == 0.0) {',\n\t\t\t\t'h = 0.0;', //no DC term\n\t\t\t'}',\n\t\t\t'gl_FragColor = vec4(h, 0.0, 0.0, 0.0);',\n\t\t'}'\n\t].join('\\n')\n};\nTHREE.ShaderLib['ocean_phase'] = {\n\tuniforms: {\n\t\t\"u_phases\": { type: \"t\", value: null },\n\t\t\"u_deltaTime\": { type: \"f\", value: null },\n\t\t\"u_resolution\": { type: \"f\", value: null },\n\t\t\"u_size\": { type: \"f\", value: null },\n\t},\n\tvarying: {\n\t\t\"vUV\": { type: \"v2\" }\n\t},\n\tfragmentShader: [\n\n\t\t'const float PI = 3.14159265359;',\n\t\t'const float G = 9.81;',\n\t\t'const float KM = 370.0;',\n\n\t\t'varying vec2 vUV;',\n\n\t\t'uniform sampler2D u_phases;',\n\t\t'uniform float u_deltaTime;',\n\t\t'uniform float u_resolution;',\n\t\t'uniform float u_size;',\n\n\t\t'float omega (float k) {',\n\t\t\t'return sqrt(G * k * (1.0 + k * k / KM * KM));',\n\t\t'}',\n\n\t\t'void main (void) {',\n\t\t\t'vec2 coordinates = gl_FragCoord.xy - 0.5;',\n\t\t\t'float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;',\n\t\t\t'float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;',\n\t\t\t'vec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;',\n\n\t\t\t'float phase = texture2D(u_phases, vUV).r;',\n\t\t\t'float deltaPhase = omega(length(waveVector)) * u_deltaTime;',\n\t\t\t'phase = mod(phase + deltaPhase, 2.0 * PI);',\n\t\t\n\t\t\t'gl_FragColor = vec4(phase, 0.0, 0.0, 0.0);',\n\t\t'}'\n\t].join('\\n')\n};\nTHREE.ShaderLib['ocean_spectrum'] = {\n\tuniforms: {\n\t\t\"u_size\": { type: \"f\", value: null },\n\t\t\"u_resolution\": { type: \"f\", value: null },\n\t\t\"u_choppiness\": { type: \"f\", value: null },\n\t\t\"u_phases\": { type: \"t\", value: null },\n\t\t\"u_initialSpectrum\": { type: \"t\", value: null },\n\t},\n\tvarying: {\n\t\t\"vUV\": { type: \"v2\" }\n\t},\n\tfragmentShader: [\n\n\t\t'const float PI = 3.14159265359;',\n\t\t'const float G = 9.81;',\n\t\t'const float KM = 370.0;',\n\n\t\t'varying vec2 vUV;',\n\n\t\t'uniform float u_size;',\n\t\t'uniform float u_resolution;',\n\t\t'uniform float u_choppiness;',\n\t\t'uniform sampler2D u_phases;',\n\t\t'uniform sampler2D u_initialSpectrum;',\n\n\t\t'vec2 multiplyComplex (vec2 a, vec2 b) {',\n\t\t\t'return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);',\n\t\t'}',\n\n\t\t'vec2 multiplyByI (vec2 z) {',\n\t\t\t'return vec2(-z[1], z[0]);',\n\t\t'}',\n\n\t\t'float omega (float k) {',\n\t\t\t'return sqrt(G * k * (1.0 + k * k / KM * KM));',\n\t\t'}',\n\n\t\t'void main (void) {',\n\t\t\t'vec2 coordinates = gl_FragCoord.xy - 0.5;',\n\t\t\t'float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;',\n\t\t\t'float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;',\n\t\t\t'vec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;',\n\n\t\t\t'float phase = texture2D(u_phases, vUV).r;',\n\t\t\t'vec2 phaseVector = vec2(cos(phase), sin(phase));',\n\n\t\t\t'vec2 h0 = texture2D(u_initialSpectrum, vUV).rg;',\n\t\t\t'vec2 h0Star = texture2D(u_initialSpectrum, vec2(1.0 - vUV + 1.0 / u_resolution)).rg;',\n\t\t\t'h0Star.y *= -1.0;',\n\n\t\t\t'vec2 h = multiplyComplex(h0, phaseVector) + multiplyComplex(h0Star, vec2(phaseVector.x, -phaseVector.y));',\n\n\t\t\t'vec2 hX = -multiplyByI(h * (waveVector.x / length(waveVector))) * u_choppiness;',\n\t\t\t'vec2 hZ = -multiplyByI(h * (waveVector.y / length(waveVector))) * u_choppiness;',\n\n\t\t\t//no DC term\n\t\t\t'if (waveVector.x == 0.0 && waveVector.y == 0.0) {',\n\t\t\t\t'h = vec2(0.0);',\n\t\t\t\t'hX = vec2(0.0);',\n\t\t\t\t'hZ = vec2(0.0);',\n\t\t\t'}',\n\t\t\n\t\t\t'gl_FragColor = vec4(hX + multiplyByI(h), hZ);',\n\t\t'}'\n\t].join('\\n')\n};\nTHREE.ShaderLib['ocean_normals'] = {\n\tuniforms: {\n\t\t\"u_displacementMap\": { type: \"t\", value: null },\n\t\t\"u_resolution\": { type: \"f\", value: null },\n\t\t\"u_size\": { type: \"f\", value: null },\n\t},\n\tvarying: {\n\t\t\"vUV\": { type: \"v2\" }\n\t},\n\tfragmentShader: [\n\n\t\t'varying vec2 vUV;',\n\t\t\n\t\t'uniform sampler2D u_displacementMap;',\n\t\t'uniform float u_resolution;',\n\t\t'uniform float u_size;',\n\n\t\t'void main (void) {',\n\t\t\t'float texel = 1.0 / u_resolution;',\n\t\t\t'float texelSize = u_size / u_resolution;',\n\n\t\t\t'vec3 center = texture2D(u_displacementMap, vUV).rgb;',\n\t\t\t'vec3 right = vec3(texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(texel, 0.0)).rgb - center;',\n\t\t\t'vec3 left = vec3(-texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(-texel, 0.0)).rgb - center;',\n\t\t\t'vec3 top = vec3(0.0, 0.0, -texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, -texel)).rgb - center;',\n\t\t\t'vec3 bottom = vec3(0.0, 0.0, texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, texel)).rgb - center;',\n\n\t\t\t'vec3 topRight = cross(right, top);',\n\t\t\t'vec3 topLeft = cross(top, left);',\n\t\t\t'vec3 bottomLeft = cross(left, bottom);',\n\t\t\t'vec3 bottomRight = cross(bottom, right);',\n\t\t\n\t\t\t'gl_FragColor = vec4(normalize(topRight + topLeft + bottomLeft + bottomRight), 1.0);',\n\t\t'}'\n\t].join('\\n')\n};\n\nTHREE.UniformsLib[ \"oceanfft\" ] = {\n\n\t\"u_displacementMap\": { type: \"t\", value: null },\n\t\"u_reflection\": { type: \"t\", value: null },\n\t\"u_normalMap\": { type: \"t\", value: null },\n\t\"u_geometrySize\": { type: \"f\", value: null },\n\t\"u_size\": { type: \"f\", value: null },\n\t\"u_mirrorMatrix\": { type: \"m4\", value: null },\n\t\"u_cameraPosition\": { type: \"v3\", value: null },\n\t\"u_skyColor\": { type: \"v3\", value: null },\n\t\"u_oceanColor\": { type: \"v3\", value: null },\n\t\"u_sunDirection\": { type: \"v3\", value: null },\n\t\"u_exposure\": { type: \"f\", value: null },\n\n},\n\nTHREE.ShaderChunk[ \"oceanfft_pars_vertex\" ] = [\n\n\t'uniform sampler2D u_displacementMap;',\n\t'uniform float u_geometrySize;',\n\t'uniform float u_size;',\n\t\t\n].join('\\n');\n\nTHREE.ShaderChunk[ \"oceanfft_vertex\" ] = [\n\n\t'vec3 displacement = texture2D( u_displacementMap, worldPosition.xz * 0.002 ).rgb * ( u_geometrySize / u_size );',\n\t'vec4 oceanfftWorldPosition = worldPosition + vec4( displacement, 0.0 );',\n\t\n].join('\\n');\n\nTHREE.ShaderChunk[ \"oceanfft_pars_fragment\" ] = [\n  \n].join('\\n');\n\nTHREE.ShaderChunk[ \"oceanfft_fragment\" ] = [\n\t\n].join('\\n');\n"],"names":["THREE","ShaderLib","varying","type","vertexShader","uniforms","value","fragmentShader","Vector2","UniformsLib","ShaderChunk"],"version":3,"file":"index.89a58267.js.map"}