{"mappings":"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","sources":["<anon>","js/loaders/MTLLoader.js"],"sourcesContent":["/**\n * Loads a Wavefront .mtl file specifying materials\n *\n * @author angelxuanchang\n */ THREE.MTLLoader = function(baseUrl, options, crossOrigin) {\n    this.baseUrl = baseUrl;\n    this.options = options;\n    this.crossOrigin = crossOrigin;\n};\nTHREE.MTLLoader.prototype = {\n    constructor: THREE.MTLLoader,\n    load: function(url, onLoad, onProgress, onError) {\n        var scope = this;\n        var loader = new THREE.XHRLoader();\n        loader.setCrossOrigin(this.crossOrigin);\n        loader.load(url, function(text) {\n            onLoad(scope.parse(text));\n        }, onProgress, onError);\n    },\n    /**\n\t * Parses loaded MTL file\n\t * @param text - Content of MTL file\n\t * @return {THREE.MTLLoader.MaterialCreator}\n\t */ parse: function(text) {\n        var lines = text.split(\"\\n\");\n        var info = {};\n        var delimiter_pattern = /\\s+/;\n        var materialsInfo = {};\n        for(var i = 0; i < lines.length; i++){\n            var line = lines[i];\n            line = line.trim();\n            if (line.length === 0 || line.charAt(0) === \"#\") continue;\n            var pos = line.indexOf(\" \");\n            var key = pos >= 0 ? line.substring(0, pos) : line;\n            key = key.toLowerCase();\n            var value = pos >= 0 ? line.substring(pos + 1) : \"\";\n            value = value.trim();\n            if (key === \"newmtl\") {\n                // New material\n                info = {\n                    name: value\n                };\n                materialsInfo[value] = info;\n            } else if (info) {\n                if (key === \"ka\" || key === \"kd\" || key === \"ks\") {\n                    var ss = value.split(delimiter_pattern, 3);\n                    info[key] = [\n                        parseFloat(ss[0]),\n                        parseFloat(ss[1]),\n                        parseFloat(ss[2])\n                    ];\n                } else info[key] = value;\n            }\n        }\n        var materialCreator = new THREE.MTLLoader.MaterialCreator(this.baseUrl, this.options);\n        materialCreator.crossOrigin = this.crossOrigin;\n        materialCreator.setMaterials(materialsInfo);\n        return materialCreator;\n    }\n};\n/**\n * Create a new THREE-MTLLoader.MaterialCreator\n * @param baseUrl - Url relative to which textures are loaded\n * @param options - Set of options on how to construct the materials\n *                  side: Which side to apply the material\n *                        THREE.FrontSide (default), THREE.BackSide, THREE.DoubleSide\n *                  wrap: What type of wrapping to apply for textures\n *                        THREE.RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping\n *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255\n *                                Default: false, assumed to be already normalized\n *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's\n *                                  Default: false\n *                  invertTransparency: If transparency need to be inverted (inversion is needed if d = 0 is fully opaque)\n *                                      Default: false (d = 1 is fully opaque)\n * @constructor\n */ THREE.MTLLoader.MaterialCreator = function(baseUrl, options) {\n    this.baseUrl = baseUrl;\n    this.options = options;\n    this.materialsInfo = {};\n    this.materials = {};\n    this.materialsArray = [];\n    this.nameLookup = {};\n    this.side = this.options && this.options.side ? this.options.side : THREE.FrontSide;\n    this.wrap = this.options && this.options.wrap ? this.options.wrap : THREE.RepeatWrapping;\n};\nTHREE.MTLLoader.MaterialCreator.prototype = {\n    constructor: THREE.MTLLoader.MaterialCreator,\n    setMaterials: function(materialsInfo) {\n        this.materialsInfo = this.convert(materialsInfo);\n        this.materials = {};\n        this.materialsArray = [];\n        this.nameLookup = {};\n    },\n    convert: function(materialsInfo) {\n        if (!this.options) return materialsInfo;\n        var converted = {};\n        for(var mn in materialsInfo){\n            // Convert materials info into normalized form based on options\n            var mat = materialsInfo[mn];\n            var covmat = {};\n            converted[mn] = covmat;\n            for(var prop in mat){\n                var save = true;\n                var value = mat[prop];\n                var lprop = prop.toLowerCase();\n                switch(lprop){\n                    case \"kd\":\n                    case \"ka\":\n                    case \"ks\":\n                        // Diffuse color (color under white light) using RGB values\n                        if (this.options && this.options.normalizeRGB) value = [\n                            value[0] / 255,\n                            value[1] / 255,\n                            value[2] / 255\n                        ];\n                        if (this.options && this.options.ignoreZeroRGBs) {\n                            if (value[0] === 0 && value[1] === 0 && value[1] === 0) // ignore\n                            save = false;\n                        }\n                        break;\n                    case \"d\":\n                        // According to MTL format (http://paulbourke.net/dataformats/mtl/):\n                        //   d is dissolve for current material\n                        //   factor of 1.0 is fully opaque, a factor of 0 is fully dissolved (completely transparent)\n                        if (this.options && this.options.invertTransparency) value = 1 - value;\n                        break;\n                    default:\n                        break;\n                }\n                if (save) covmat[lprop] = value;\n            }\n        }\n        return converted;\n    },\n    preload: function() {\n        for(var mn in this.materialsInfo)this.create(mn);\n    },\n    getIndex: function(materialName) {\n        return this.nameLookup[materialName];\n    },\n    getAsArray: function() {\n        var index = 0;\n        for(var mn in this.materialsInfo){\n            this.materialsArray[index] = this.create(mn);\n            this.nameLookup[mn] = index;\n            index++;\n        }\n        return this.materialsArray;\n    },\n    create: function(materialName) {\n        if (this.materials[materialName] === undefined) this.createMaterial_(materialName);\n        return this.materials[materialName];\n    },\n    createMaterial_: function(materialName) {\n        // Create material\n        var mat = this.materialsInfo[materialName];\n        var params = {\n            name: materialName,\n            side: this.side\n        };\n        for(var prop in mat){\n            var value = mat[prop];\n            switch(prop.toLowerCase()){\n                // Ns is material specular exponent\n                case \"kd\":\n                    // Diffuse color (color under white light) using RGB values\n                    params[\"diffuse\"] = new THREE.Color().fromArray(value);\n                    break;\n                case \"ka\":\n                    break;\n                case \"ks\":\n                    // Specular color (color when light is reflected from shiny surface) using RGB values\n                    params[\"specular\"] = new THREE.Color().fromArray(value);\n                    break;\n                case \"map_kd\":\n                    // Diffuse texture map\n                    params[\"map\"] = this.loadTexture(this.baseUrl + value);\n                    params[\"map\"].wrapS = this.wrap;\n                    params[\"map\"].wrapT = this.wrap;\n                    break;\n                case \"ns\":\n                    // The specular exponent (defines the focus of the specular highlight)\n                    // A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\n                    params[\"shininess\"] = value;\n                    break;\n                case \"d\":\n                    // According to MTL format (http://paulbourke.net/dataformats/mtl/):\n                    //   d is dissolve for current material\n                    //   factor of 1.0 is fully opaque, a factor of 0 is fully dissolved (completely transparent)\n                    if (value < 1) {\n                        params[\"transparent\"] = true;\n                        params[\"opacity\"] = value;\n                    }\n                    break;\n                case \"map_bump\":\n                case \"bump\":\n                    // Bump texture map\n                    if (params[\"bumpMap\"]) break; // Avoid loading twice.\n                    params[\"bumpMap\"] = this.loadTexture(this.baseUrl + value);\n                    params[\"bumpMap\"].wrapS = this.wrap;\n                    params[\"bumpMap\"].wrapT = this.wrap;\n                    break;\n                default:\n                    break;\n            }\n        }\n        if (params[\"diffuse\"]) params[\"color\"] = params[\"diffuse\"];\n        this.materials[materialName] = new THREE.MeshPhongMaterial(params);\n        return this.materials[materialName];\n    },\n    loadTexture: function(url, mapping, onLoad, onError) {\n        var texture;\n        var loader = THREE.Loader.Handlers.get(url);\n        if (loader !== null) texture = loader.load(url, onLoad);\n        else {\n            texture = new THREE.Texture();\n            loader = new THREE.ImageLoader();\n            loader.crossOrigin = this.crossOrigin;\n            loader.load(url, function(image) {\n                texture.image = THREE.MTLLoader.ensurePowerOfTwo_(image);\n                texture.needsUpdate = true;\n                if (onLoad) onLoad(texture);\n            });\n        }\n        if (mapping !== undefined) texture.mapping = mapping;\n        return texture;\n    }\n};\nTHREE.MTLLoader.ensurePowerOfTwo_ = function(image) {\n    if (!THREE.Math.isPowerOfTwo(image.width) || !THREE.Math.isPowerOfTwo(image.height)) {\n        var canvas = document.createElement(\"canvas\");\n        canvas.width = THREE.MTLLoader.nextHighestPowerOfTwo_(image.width);\n        canvas.height = THREE.MTLLoader.nextHighestPowerOfTwo_(image.height);\n        var ctx = canvas.getContext(\"2d\");\n        ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);\n        return canvas;\n    }\n    return image;\n};\nTHREE.MTLLoader.nextHighestPowerOfTwo_ = function(x) {\n    --x;\n    for(var i = 1; i < 32; i <<= 1)x = x | x >> i;\n    return x + 1;\n};\nTHREE.EventDispatcher.prototype.apply(THREE.MTLLoader.prototype);\n\n//# sourceMappingURL=index.da3cae0a.js.map\n","/**\n * Loads a Wavefront .mtl file specifying materials\n *\n * @author angelxuanchang\n */\n\nTHREE.MTLLoader = function( baseUrl, options, crossOrigin ) {\n\n\tthis.baseUrl = baseUrl;\n\tthis.options = options;\n\tthis.crossOrigin = crossOrigin;\n\n};\n\nTHREE.MTLLoader.prototype = {\n\n\tconstructor: THREE.MTLLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.XHRLoader();\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tonLoad( scope.parse( text ) );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\t/**\n\t * Parses loaded MTL file\n\t * @param text - Content of MTL file\n\t * @return {THREE.MTLLoader.MaterialCreator}\n\t */\n\tparse: function ( text ) {\n\n\t\tvar lines = text.split( \"\\n\" );\n\t\tvar info = {};\n\t\tvar delimiter_pattern = /\\s+/;\n\t\tvar materialsInfo = {};\n\n\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\tvar line = lines[ i ];\n\t\t\tline = line.trim();\n\n\t\t\tif ( line.length === 0 || line.charAt( 0 ) === '#' ) {\n\n\t\t\t\t// Blank line or comment ignore\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tvar pos = line.indexOf( ' ' );\n\n\t\t\tvar key = ( pos >= 0 ) ? line.substring( 0, pos ) : line;\n\t\t\tkey = key.toLowerCase();\n\n\t\t\tvar value = ( pos >= 0 ) ? line.substring( pos + 1 ) : \"\";\n\t\t\tvalue = value.trim();\n\n\t\t\tif ( key === \"newmtl\" ) {\n\n\t\t\t\t// New material\n\n\t\t\t\tinfo = { name: value };\n\t\t\t\tmaterialsInfo[ value ] = info;\n\n\t\t\t} else if ( info ) {\n\n\t\t\t\tif ( key === \"ka\" || key === \"kd\" || key === \"ks\" ) {\n\n\t\t\t\t\tvar ss = value.split( delimiter_pattern, 3 );\n\t\t\t\t\tinfo[ key ] = [ parseFloat( ss[0] ), parseFloat( ss[1] ), parseFloat( ss[2] ) ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tinfo[ key ] = value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar materialCreator = new THREE.MTLLoader.MaterialCreator( this.baseUrl, this.options );\n\t\tmaterialCreator.crossOrigin = this.crossOrigin\n\t\tmaterialCreator.setMaterials( materialsInfo );\n\t\treturn materialCreator;\n\n\t}\n\n};\n\n/**\n * Create a new THREE-MTLLoader.MaterialCreator\n * @param baseUrl - Url relative to which textures are loaded\n * @param options - Set of options on how to construct the materials\n *                  side: Which side to apply the material\n *                        THREE.FrontSide (default), THREE.BackSide, THREE.DoubleSide\n *                  wrap: What type of wrapping to apply for textures\n *                        THREE.RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping\n *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255\n *                                Default: false, assumed to be already normalized\n *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's\n *                                  Default: false\n *                  invertTransparency: If transparency need to be inverted (inversion is needed if d = 0 is fully opaque)\n *                                      Default: false (d = 1 is fully opaque)\n * @constructor\n */\n\nTHREE.MTLLoader.MaterialCreator = function( baseUrl, options ) {\n\n\tthis.baseUrl = baseUrl;\n\tthis.options = options;\n\tthis.materialsInfo = {};\n\tthis.materials = {};\n\tthis.materialsArray = [];\n\tthis.nameLookup = {};\n\n\tthis.side = ( this.options && this.options.side ) ? this.options.side : THREE.FrontSide;\n\tthis.wrap = ( this.options && this.options.wrap ) ? this.options.wrap : THREE.RepeatWrapping;\n\n};\n\nTHREE.MTLLoader.MaterialCreator.prototype = {\n\n\tconstructor: THREE.MTLLoader.MaterialCreator,\n\n\tsetMaterials: function( materialsInfo ) {\n\n\t\tthis.materialsInfo = this.convert( materialsInfo );\n\t\tthis.materials = {};\n\t\tthis.materialsArray = [];\n\t\tthis.nameLookup = {};\n\n\t},\n\n\tconvert: function( materialsInfo ) {\n\n\t\tif ( !this.options ) return materialsInfo;\n\n\t\tvar converted = {};\n\n\t\tfor ( var mn in materialsInfo ) {\n\n\t\t\t// Convert materials info into normalized form based on options\n\n\t\t\tvar mat = materialsInfo[ mn ];\n\n\t\t\tvar covmat = {};\n\n\t\t\tconverted[ mn ] = covmat;\n\n\t\t\tfor ( var prop in mat ) {\n\n\t\t\t\tvar save = true;\n\t\t\t\tvar value = mat[ prop ];\n\t\t\t\tvar lprop = prop.toLowerCase();\n\n\t\t\t\tswitch ( lprop ) {\n\n\t\t\t\t\tcase 'kd':\n\t\t\t\t\tcase 'ka':\n\t\t\t\t\tcase 'ks':\n\n\t\t\t\t\t\t// Diffuse color (color under white light) using RGB values\n\n\t\t\t\t\t\tif ( this.options && this.options.normalizeRGB ) {\n\n\t\t\t\t\t\t\tvalue = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( this.options && this.options.ignoreZeroRGBs ) {\n\n\t\t\t\t\t\t\tif ( value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 1 ] === 0 ) {\n\n\t\t\t\t\t\t\t\t// ignore\n\n\t\t\t\t\t\t\t\tsave = false;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'd':\n\n\t\t\t\t\t\t// According to MTL format (http://paulbourke.net/dataformats/mtl/):\n\t\t\t\t\t\t//   d is dissolve for current material\n\t\t\t\t\t\t//   factor of 1.0 is fully opaque, a factor of 0 is fully dissolved (completely transparent)\n\n\t\t\t\t\t\tif ( this.options && this.options.invertTransparency ) {\n\n\t\t\t\t\t\t\tvalue = 1 - value;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ( save ) {\n\n\t\t\t\t\tcovmat[ lprop ] = value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn converted;\n\n\t},\n\n\tpreload: function () {\n\n\t\tfor ( var mn in this.materialsInfo ) {\n\n\t\t\tthis.create( mn );\n\n\t\t}\n\n\t},\n\n\tgetIndex: function( materialName ) {\n\n\t\treturn this.nameLookup[ materialName ];\n\n\t},\n\n\tgetAsArray: function() {\n\n\t\tvar index = 0;\n\n\t\tfor ( var mn in this.materialsInfo ) {\n\n\t\t\tthis.materialsArray[ index ] = this.create( mn );\n\t\t\tthis.nameLookup[ mn ] = index;\n\t\t\tindex ++;\n\n\t\t}\n\n\t\treturn this.materialsArray;\n\n\t},\n\n\tcreate: function ( materialName ) {\n\n\t\tif ( this.materials[ materialName ] === undefined ) {\n\n\t\t\tthis.createMaterial_( materialName );\n\n\t\t}\n\n\t\treturn this.materials[ materialName ];\n\n\t},\n\n\tcreateMaterial_: function ( materialName ) {\n\n\t\t// Create material\n\n\t\tvar mat = this.materialsInfo[ materialName ];\n\t\tvar params = {\n\n\t\t\tname: materialName,\n\t\t\tside: this.side\n\n\t\t};\n\n\t\tfor ( var prop in mat ) {\n\n\t\t\tvar value = mat[ prop ];\n\n\t\t\tswitch ( prop.toLowerCase() ) {\n\n\t\t\t\t// Ns is material specular exponent\n\n\t\t\t\tcase 'kd':\n\n\t\t\t\t\t// Diffuse color (color under white light) using RGB values\n\n\t\t\t\t\tparams[ 'diffuse' ] = new THREE.Color().fromArray( value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ka':\n\n\t\t\t\t\t// Ambient color (color under shadow) using RGB values\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ks':\n\n\t\t\t\t\t// Specular color (color when light is reflected from shiny surface) using RGB values\n\t\t\t\t\tparams[ 'specular' ] = new THREE.Color().fromArray( value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_kd':\n\n\t\t\t\t\t// Diffuse texture map\n\n\t\t\t\t\tparams[ 'map' ] = this.loadTexture( this.baseUrl + value );\n\t\t\t\t\tparams[ 'map' ].wrapS = this.wrap;\n\t\t\t\t\tparams[ 'map' ].wrapT = this.wrap;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ns':\n\n\t\t\t\t\t// The specular exponent (defines the focus of the specular highlight)\n\t\t\t\t\t// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\n\n\t\t\t\t\tparams['shininess'] = value;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'd':\n\n\t\t\t\t\t// According to MTL format (http://paulbourke.net/dataformats/mtl/):\n\t\t\t\t\t//   d is dissolve for current material\n\t\t\t\t\t//   factor of 1.0 is fully opaque, a factor of 0 is fully dissolved (completely transparent)\n\n\t\t\t\t\tif ( value < 1 ) {\n\n\t\t\t\t\t\tparams['transparent'] = true;\n\t\t\t\t\t\tparams['opacity'] = value;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_bump':\n\t\t\t\tcase 'bump':\n\n\t\t\t\t\t// Bump texture map\n\n\t\t\t\t\tif ( params[ 'bumpMap' ] ) break; // Avoid loading twice.\n\n\t\t\t\t\tparams[ 'bumpMap' ] = this.loadTexture( this.baseUrl + value );\n\t\t\t\t\tparams[ 'bumpMap' ].wrapS = this.wrap;\n\t\t\t\t\tparams[ 'bumpMap' ].wrapT = this.wrap;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( params[ 'diffuse' ] ) {\n\n\t\t\tparams[ 'color' ] = params[ 'diffuse' ];\n\n\t\t}\n\n\t\tthis.materials[ materialName ] = new THREE.MeshPhongMaterial( params );\n\t\treturn this.materials[ materialName ];\n\n\t},\n\n\n\tloadTexture: function ( url, mapping, onLoad, onError ) {\n\n\t\tvar texture;\n\t\tvar loader = THREE.Loader.Handlers.get( url );\n\n\t\tif ( loader !== null ) {\n\n\t\t\ttexture = loader.load( url, onLoad );\n\n\t\t} else {\n\n\t\t\ttexture = new THREE.Texture();\n\n\t\t\tloader = new THREE.ImageLoader();\n\t\t\tloader.crossOrigin = this.crossOrigin;\n\t\t\tloader.load( url, function ( image ) {\n\n\t\t\t\ttexture.image = THREE.MTLLoader.ensurePowerOfTwo_( image );\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t} );\n\n\t\t}\n\n\t\tif ( mapping !== undefined ) texture.mapping = mapping;\n\n\t\treturn texture;\n\n\t}\n\n};\n\nTHREE.MTLLoader.ensurePowerOfTwo_ = function ( image ) {\n\n\tif ( ! THREE.Math.isPowerOfTwo( image.width ) || ! THREE.Math.isPowerOfTwo( image.height ) ) {\n\n\t\tvar canvas = document.createElement( \"canvas\" );\n\t\tcanvas.width = THREE.MTLLoader.nextHighestPowerOfTwo_( image.width );\n\t\tcanvas.height = THREE.MTLLoader.nextHighestPowerOfTwo_( image.height );\n\n\t\tvar ctx = canvas.getContext(\"2d\");\n\t\tctx.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\n\t\treturn canvas;\n\n\t}\n\n\treturn image;\n\n};\n\nTHREE.MTLLoader.nextHighestPowerOfTwo_ = function( x ) {\n\n\t-- x;\n\n\tfor ( var i = 1; i < 32; i <<= 1 ) {\n\n\t\tx = x | x >> i;\n\n\t}\n\n\treturn x + 1;\n\n};\n\nTHREE.EventDispatcher.prototype.apply( THREE.MTLLoader.prototype );"],"names":["THREE","MTLLoader","baseUrl","options","crossOrigin","prototype","constructor","load","url","onLoad","onProgress","onError","scope","loader","XHRLoader","setCrossOrigin","text","parse","lines","split","info","delimiter_pattern","materialsInfo","i","length","line","trim","charAt","pos","indexOf","key","substring","toLowerCase","value","name","ss","parseFloat","materialCreator","MaterialCreator","setMaterials","materials","materialsArray","nameLookup","side","FrontSide","wrap","RepeatWrapping","convert","converted","mn","mat","covmat","prop","save","lprop","normalizeRGB","ignoreZeroRGBs","invertTransparency","preload","create","getIndex","materialName","getAsArray","index","undefined","createMaterial_","params","Color","fromArray","loadTexture","wrapS","wrapT","MeshPhongMaterial","mapping","texture","Loader","Handlers","get","Texture","ImageLoader","image","ensurePowerOfTwo_","needsUpdate","Math","isPowerOfTwo","width","height","canvas","document","createElement","nextHighestPowerOfTwo_","ctx","getContext","drawImage","x","EventDispatcher","apply"],"version":3,"file":"index.da3cae0a.js.map"}