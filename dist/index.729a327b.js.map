{"mappings":"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","sources":["<anon>","js/loaders/OBJMTLLoader.js"],"sourcesContent":["/**\n * Loads a Wavefront .obj file with materials\n *\n * @author mrdoob / http://mrdoob.com/\n * @author angelxuanchang\n */ THREE.OBJMTLLoader = function(manager) {\n    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\nTHREE.OBJMTLLoader.prototype = {\n    constructor: THREE.OBJMTLLoader,\n    load: function(url, mtlurl, onLoad, onProgress, onError) {\n        var scope = this;\n        var mtlLoader = new THREE.MTLLoader(url.substr(0, url.lastIndexOf(\"/\") + 1));\n        mtlLoader.crossOrigin = scope.crossOrigin;\n        mtlLoader.load(mtlurl, function(materials) {\n            var materialsCreator = materials;\n            materialsCreator.preload();\n            var loader = new THREE.XHRLoader(scope.manager);\n            loader.setCrossOrigin(scope.crossOrigin);\n            loader.load(url, function(text) {\n                var object = scope.parse(text);\n                object.traverse(function(object) {\n                    if (object instanceof THREE.Mesh) {\n                        if (object.material.name) {\n                            var material = materialsCreator.create(object.material.name);\n                            if (material) object.material = material;\n                        }\n                    }\n                });\n                onLoad(object);\n            }, onProgress, onError);\n        }, onProgress, onError);\n    },\n    /**\n\t * Parses loaded .obj file\n\t * @param data - content of .obj file\n\t * @param mtllibCallback - callback to handle mtllib declaration (optional)\n\t * @return {THREE.Object3D} - Object3D (with default material)\n\t */ parse: function(data, mtllibCallback) {\n        function vector(x, y, z) {\n            return new THREE.Vector3(x, y, z);\n        }\n        function uv(u, v) {\n            return new THREE.Vector2(u, v);\n        }\n        function face3(a, b, c, normals) {\n            return new THREE.Face3(a, b, c, normals);\n        }\n        var face_offset = 0;\n        function meshN(meshName, materialName) {\n            if (vertices.length > 0) {\n                geometry.vertices = vertices;\n                geometry.mergeVertices();\n                geometry.computeFaceNormals();\n                geometry.computeBoundingSphere();\n                object.add(mesh);\n                geometry = new THREE.Geometry();\n                mesh = new THREE.Mesh(geometry, material);\n            }\n            if (meshName !== undefined) mesh.name = meshName;\n            if (materialName !== undefined) {\n                material = new THREE.MeshLambertMaterial();\n                material.name = materialName;\n                mesh.material = material;\n            }\n        }\n        var group = new THREE.Group();\n        var object = group;\n        var geometry = new THREE.Geometry();\n        var material = new THREE.MeshLambertMaterial();\n        var mesh = new THREE.Mesh(geometry, material);\n        var vertices = [];\n        var normals = [];\n        var uvs = [];\n        function add_face(a, b, c, normals_inds) {\n            if (normals_inds === undefined) geometry.faces.push(face3(parseInt(a) - (face_offset + 1), parseInt(b) - (face_offset + 1), parseInt(c) - (face_offset + 1)));\n            else geometry.faces.push(face3(parseInt(a) - (face_offset + 1), parseInt(b) - (face_offset + 1), parseInt(c) - (face_offset + 1), [\n                normals[parseInt(normals_inds[0]) - 1].clone(),\n                normals[parseInt(normals_inds[1]) - 1].clone(),\n                normals[parseInt(normals_inds[2]) - 1].clone()\n            ]));\n        }\n        function add_uvs(a, b, c) {\n            geometry.faceVertexUvs[0].push([\n                uvs[parseInt(a) - 1].clone(),\n                uvs[parseInt(b) - 1].clone(),\n                uvs[parseInt(c) - 1].clone()\n            ]);\n        }\n        function handle_face_line(faces, uvs, normals_inds) {\n            if (faces[3] === undefined) {\n                add_face(faces[0], faces[1], faces[2], normals_inds);\n                if (!(uvs === undefined) && uvs.length > 0) add_uvs(uvs[0], uvs[1], uvs[2]);\n            } else {\n                if (!(normals_inds === undefined) && normals_inds.length > 0) {\n                    add_face(faces[0], faces[1], faces[3], [\n                        normals_inds[0],\n                        normals_inds[1],\n                        normals_inds[3]\n                    ]);\n                    add_face(faces[1], faces[2], faces[3], [\n                        normals_inds[1],\n                        normals_inds[2],\n                        normals_inds[3]\n                    ]);\n                } else {\n                    add_face(faces[0], faces[1], faces[3]);\n                    add_face(faces[1], faces[2], faces[3]);\n                }\n                if (!(uvs === undefined) && uvs.length > 0) {\n                    add_uvs(uvs[0], uvs[1], uvs[3]);\n                    add_uvs(uvs[1], uvs[2], uvs[3]);\n                }\n            }\n        }\n        // v float float float\n        var vertex_pattern = /v( +[\\d|\\.|\\+|\\-|e]+)( +[\\d|\\.|\\+|\\-|e]+)( +[\\d|\\.|\\+|\\-|e]+)/;\n        // vn float float float\n        var normal_pattern = /vn( +[\\d|\\.|\\+|\\-|e]+)( +[\\d|\\.|\\+|\\-|e]+)( +[\\d|\\.|\\+|\\-|e]+)/;\n        // vt float float\n        var uv_pattern = /vt( +[\\d|\\.|\\+|\\-|e]+)( +[\\d|\\.|\\+|\\-|e]+)/;\n        // f vertex vertex vertex ...\n        var face_pattern1 = /f( +\\d+)( +\\d+)( +\\d+)( +\\d+)?/;\n        // f vertex/uv vertex/uv vertex/uv ...\n        var face_pattern2 = /f( +(\\d+)\\/(\\d+))( +(\\d+)\\/(\\d+))( +(\\d+)\\/(\\d+))( +(\\d+)\\/(\\d+))?/;\n        // f vertex/uv/normal vertex/uv/normal vertex/uv/normal ...\n        var face_pattern3 = /f( +(\\d+)\\/(\\d+)\\/(\\d+))( +(\\d+)\\/(\\d+)\\/(\\d+))( +(\\d+)\\/(\\d+)\\/(\\d+))( +(\\d+)\\/(\\d+)\\/(\\d+))?/;\n        // f vertex//normal vertex//normal vertex//normal ...\n        var face_pattern4 = /f( +(\\d+)\\/\\/(\\d+))( +(\\d+)\\/\\/(\\d+))( +(\\d+)\\/\\/(\\d+))( +(\\d+)\\/\\/(\\d+))?/;\n        //\n        var lines = data.split(\"\\n\");\n        for(var i = 0; i < lines.length; i++){\n            var line = lines[i];\n            line = line.trim();\n            var result;\n            if (line.length === 0 || line.charAt(0) === \"#\") continue;\n            else if ((result = vertex_pattern.exec(line)) !== null) // [\"v 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n            vertices.push(vector(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));\n            else if ((result = normal_pattern.exec(line)) !== null) // [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n            normals.push(vector(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));\n            else if ((result = uv_pattern.exec(line)) !== null) // [\"vt 0.1 0.2\", \"0.1\", \"0.2\"]\n            uvs.push(uv(parseFloat(result[1]), parseFloat(result[2])));\n            else if ((result = face_pattern1.exec(line)) !== null) // [\"f 1 2 3\", \"1\", \"2\", \"3\", undefined]\n            handle_face_line([\n                result[1],\n                result[2],\n                result[3],\n                result[4]\n            ]);\n            else if ((result = face_pattern2.exec(line)) !== null) // [\"f 1/1 2/2 3/3\", \" 1/1\", \"1\", \"1\", \" 2/2\", \"2\", \"2\", \" 3/3\", \"3\", \"3\", undefined, undefined, undefined]\n            handle_face_line([\n                result[2],\n                result[5],\n                result[8],\n                result[11]\n            ], [\n                result[3],\n                result[6],\n                result[9],\n                result[12]\n            ] //uv\n            );\n            else if ((result = face_pattern3.exec(line)) !== null) // [\"f 1/1/1 2/2/2 3/3/3\", \" 1/1/1\", \"1\", \"1\", \"1\", \" 2/2/2\", \"2\", \"2\", \"2\", \" 3/3/3\", \"3\", \"3\", \"3\", undefined, undefined, undefined, undefined]\n            handle_face_line([\n                result[2],\n                result[6],\n                result[10],\n                result[14]\n            ], [\n                result[3],\n                result[7],\n                result[11],\n                result[15]\n            ], [\n                result[4],\n                result[8],\n                result[12],\n                result[16]\n            ] //normal\n            );\n            else if ((result = face_pattern4.exec(line)) !== null) // [\"f 1//1 2//2 3//3\", \" 1//1\", \"1\", \"1\", \" 2//2\", \"2\", \"2\", \" 3//3\", \"3\", \"3\", undefined, undefined, undefined]\n            handle_face_line([\n                result[2],\n                result[5],\n                result[8],\n                result[11]\n            ], [], [\n                result[3],\n                result[6],\n                result[9],\n                result[12]\n            ] //normal\n            );\n            else if (/^o /.test(line)) {\n                // object\n                meshN();\n                face_offset = face_offset + vertices.length;\n                vertices = [];\n                object = new THREE.Object3D();\n                object.name = line.substring(2).trim();\n                group.add(object);\n            } else if (/^g /.test(line)) // group\n            meshN(line.substring(2).trim(), undefined);\n            else if (/^usemtl /.test(line)) // material\n            meshN(undefined, line.substring(7).trim());\n            else if (/^mtllib /.test(line)) // mtl file\n            {\n                if (mtllibCallback) {\n                    var mtlfile = line.substring(7);\n                    mtlfile = mtlfile.trim();\n                    mtllibCallback(mtlfile);\n                }\n            } else if (/^s /.test(line)) ;\n            else console.log(\"THREE.OBJMTLLoader: Unhandled line \" + line);\n        }\n        //Add last object\n        meshN(undefined, undefined);\n        return group;\n    }\n};\nTHREE.EventDispatcher.prototype.apply(THREE.OBJMTLLoader.prototype);\n\n//# sourceMappingURL=index.729a327b.js.map\n","/**\n * Loads a Wavefront .obj file with materials\n *\n * @author mrdoob / http://mrdoob.com/\n * @author angelxuanchang\n */\n\nTHREE.OBJMTLLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nTHREE.OBJMTLLoader.prototype = {\n\n\tconstructor: THREE.OBJMTLLoader,\n\n\tload: function ( url, mtlurl, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar mtlLoader = new THREE.MTLLoader( url.substr( 0, url.lastIndexOf( \"/\" ) + 1 ) );\n\t\tmtlLoader.crossOrigin = scope.crossOrigin;\n\t\tmtlLoader.load( mtlurl, function ( materials ) {\n\n\t\t\tvar materialsCreator = materials;\n\t\t\tmaterialsCreator.preload();\n\n\t\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\t\t\tloader.setCrossOrigin( scope.crossOrigin );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tvar object = scope.parse( text );\n\n\t\t\t\tobject.traverse( function ( object ) {\n\n\t\t\t\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\t\t\t\tif ( object.material.name ) {\n\n\t\t\t\t\t\t\tvar material = materialsCreator.create( object.material.name );\n\n\t\t\t\t\t\t\tif ( material ) object.material = material;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tonLoad( object );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\t/**\n\t * Parses loaded .obj file\n\t * @param data - content of .obj file\n\t * @param mtllibCallback - callback to handle mtllib declaration (optional)\n\t * @return {THREE.Object3D} - Object3D (with default material)\n\t */\n\n\tparse: function ( data, mtllibCallback ) {\n\n\t\tfunction vector( x, y, z ) {\n\n\t\t\treturn new THREE.Vector3( x, y, z );\n\n\t\t}\n\n\t\tfunction uv( u, v ) {\n\n\t\t\treturn new THREE.Vector2( u, v );\n\n\t\t}\n\n\t\tfunction face3( a, b, c, normals ) {\n\n\t\t\treturn new THREE.Face3( a, b, c, normals );\n\n\t\t}\n\n\t\tvar face_offset = 0;\n\n\t\tfunction meshN( meshName, materialName ) {\n\n\t\t\tif ( vertices.length > 0 ) {\n\n\t\t\t\tgeometry.vertices = vertices;\n\n\t\t\t\tgeometry.mergeVertices();\n\t\t\t\tgeometry.computeFaceNormals();\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t\tobject.add( mesh );\n\n\t\t\t\tgeometry = new THREE.Geometry();\n\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\n\t\t\t}\n\n\t\t\tif ( meshName !== undefined ) mesh.name = meshName;\n\n\t\t\tif ( materialName !== undefined ) {\n\n\t\t\t\tmaterial = new THREE.MeshLambertMaterial();\n\t\t\t\tmaterial.name = materialName;\n\n\t\t\t\tmesh.material = material;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar group = new THREE.Group();\n\t\tvar object = group;\n\n\t\tvar geometry = new THREE.Geometry();\n\t\tvar material = new THREE.MeshLambertMaterial();\n\t\tvar mesh = new THREE.Mesh( geometry, material );\n\n\t\tvar vertices = [];\n\t\tvar normals = [];\n\t\tvar uvs = [];\n\n\t\tfunction add_face( a, b, c, normals_inds ) {\n\n\t\t\tif ( normals_inds === undefined ) {\n\n\t\t\t\tgeometry.faces.push( face3(\n\t\t\t\t\tparseInt( a ) - (face_offset + 1),\n\t\t\t\t\tparseInt( b ) - (face_offset + 1),\n\t\t\t\t\tparseInt( c ) - (face_offset + 1)\n\t\t\t\t) );\n\n\t\t\t} else {\n\n\t\t\t\tgeometry.faces.push( face3(\n\t\t\t\t\tparseInt( a ) - (face_offset + 1),\n\t\t\t\t\tparseInt( b ) - (face_offset + 1),\n\t\t\t\t\tparseInt( c ) - (face_offset + 1),\n\t\t\t\t\t[\n\t\t\t\t\t\tnormals[ parseInt( normals_inds[ 0 ] ) - 1 ].clone(),\n\t\t\t\t\t\tnormals[ parseInt( normals_inds[ 1 ] ) - 1 ].clone(),\n\t\t\t\t\t\tnormals[ parseInt( normals_inds[ 2 ] ) - 1 ].clone()\n\t\t\t\t\t]\n\t\t\t\t) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction add_uvs( a, b, c ) {\n\n\t\t\tgeometry.faceVertexUvs[ 0 ].push( [\n\t\t\t\tuvs[ parseInt( a ) - 1 ].clone(),\n\t\t\t\tuvs[ parseInt( b ) - 1 ].clone(),\n\t\t\t\tuvs[ parseInt( c ) - 1 ].clone()\n\t\t\t] );\n\n\t\t}\n\n\t\tfunction handle_face_line(faces, uvs, normals_inds) {\n\n\t\t\tif ( faces[ 3 ] === undefined ) {\n\n\t\t\t\tadd_face( faces[ 0 ], faces[ 1 ], faces[ 2 ], normals_inds );\n\n\t\t\t\tif (!(uvs === undefined) && uvs.length > 0) {\n\t\t\t\t\tadd_uvs( uvs[ 0 ], uvs[ 1 ], uvs[ 2 ] );\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif (!(normals_inds === undefined) && normals_inds.length > 0) {\n\n\t\t\t\t\tadd_face( faces[ 0 ], faces[ 1 ], faces[ 3 ], [ normals_inds[ 0 ], normals_inds[ 1 ], normals_inds[ 3 ] ]);\n\t\t\t\t\tadd_face( faces[ 1 ], faces[ 2 ], faces[ 3 ], [ normals_inds[ 1 ], normals_inds[ 2 ], normals_inds[ 3 ] ]);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tadd_face( faces[ 0 ], faces[ 1 ], faces[ 3 ]);\n\t\t\t\t\tadd_face( faces[ 1 ], faces[ 2 ], faces[ 3 ]);\n\n\t\t\t\t}\n\n\t\t\t\tif (!(uvs === undefined) && uvs.length > 0) {\n\n\t\t\t\t\tadd_uvs( uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] );\n\t\t\t\t\tadd_uvs( uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// v float float float\n\n\t\tvar vertex_pattern = /v( +[\\d|\\.|\\+|\\-|e]+)( +[\\d|\\.|\\+|\\-|e]+)( +[\\d|\\.|\\+|\\-|e]+)/;\n\n\t\t// vn float float float\n\n\t\tvar normal_pattern = /vn( +[\\d|\\.|\\+|\\-|e]+)( +[\\d|\\.|\\+|\\-|e]+)( +[\\d|\\.|\\+|\\-|e]+)/;\n\n\t\t// vt float float\n\n\t\tvar uv_pattern = /vt( +[\\d|\\.|\\+|\\-|e]+)( +[\\d|\\.|\\+|\\-|e]+)/;\n\n\t\t// f vertex vertex vertex ...\n\n\t\tvar face_pattern1 = /f( +\\d+)( +\\d+)( +\\d+)( +\\d+)?/;\n\n\t\t// f vertex/uv vertex/uv vertex/uv ...\n\n\t\tvar face_pattern2 = /f( +(\\d+)\\/(\\d+))( +(\\d+)\\/(\\d+))( +(\\d+)\\/(\\d+))( +(\\d+)\\/(\\d+))?/;\n\n\t\t// f vertex/uv/normal vertex/uv/normal vertex/uv/normal ...\n\n\t\tvar face_pattern3 = /f( +(\\d+)\\/(\\d+)\\/(\\d+))( +(\\d+)\\/(\\d+)\\/(\\d+))( +(\\d+)\\/(\\d+)\\/(\\d+))( +(\\d+)\\/(\\d+)\\/(\\d+))?/;\n\n\t\t// f vertex//normal vertex//normal vertex//normal ...\n\n\t\tvar face_pattern4 = /f( +(\\d+)\\/\\/(\\d+))( +(\\d+)\\/\\/(\\d+))( +(\\d+)\\/\\/(\\d+))( +(\\d+)\\/\\/(\\d+))?/\n\n\t\t//\n\n\t\tvar lines = data.split( \"\\n\" );\n\n\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\tvar line = lines[ i ];\n\t\t\tline = line.trim();\n\n\t\t\tvar result;\n\n\t\t\tif ( line.length === 0 || line.charAt( 0 ) === '#' ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t} else if ( ( result = vertex_pattern.exec( line ) ) !== null ) {\n\n\t\t\t\t// [\"v 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n\n\t\t\t\tvertices.push( vector(\n\t\t\t\t\tparseFloat( result[ 1 ] ),\n\t\t\t\t\tparseFloat( result[ 2 ] ),\n\t\t\t\t\tparseFloat( result[ 3 ] )\n\t\t\t\t) );\n\n\t\t\t} else if ( ( result = normal_pattern.exec( line ) ) !== null ) {\n\n\t\t\t\t// [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n\n\t\t\t\tnormals.push( vector(\n\t\t\t\t\tparseFloat( result[ 1 ] ),\n\t\t\t\t\tparseFloat( result[ 2 ] ),\n\t\t\t\t\tparseFloat( result[ 3 ] )\n\t\t\t\t) );\n\n\t\t\t} else if ( ( result = uv_pattern.exec( line ) ) !== null ) {\n\n\t\t\t\t// [\"vt 0.1 0.2\", \"0.1\", \"0.2\"]\n\n\t\t\t\tuvs.push( uv(\n\t\t\t\t\tparseFloat( result[ 1 ] ),\n\t\t\t\t\tparseFloat( result[ 2 ] )\n\t\t\t\t) );\n\n\t\t\t} else if ( ( result = face_pattern1.exec( line ) ) !== null ) {\n\n\t\t\t\t// [\"f 1 2 3\", \"1\", \"2\", \"3\", undefined]\n\n\t\t\t\thandle_face_line([ result[ 1 ], result[ 2 ], result[ 3 ], result[ 4 ] ]);\n\n\t\t\t} else if ( ( result = face_pattern2.exec( line ) ) !== null ) {\n\n\t\t\t\t// [\"f 1/1 2/2 3/3\", \" 1/1\", \"1\", \"1\", \" 2/2\", \"2\", \"2\", \" 3/3\", \"3\", \"3\", undefined, undefined, undefined]\n\n\t\t\t\thandle_face_line(\n\t\t\t\t\t[ result[ 2 ], result[ 5 ], result[ 8 ], result[ 11 ] ], //faces\n\t\t\t\t\t[ result[ 3 ], result[ 6 ], result[ 9 ], result[ 12 ] ] //uv\n\t\t\t\t);\n\n\t\t\t} else if ( ( result = face_pattern3.exec( line ) ) !== null ) {\n\n\t\t\t\t// [\"f 1/1/1 2/2/2 3/3/3\", \" 1/1/1\", \"1\", \"1\", \"1\", \" 2/2/2\", \"2\", \"2\", \"2\", \" 3/3/3\", \"3\", \"3\", \"3\", undefined, undefined, undefined, undefined]\n\n\t\t\t\thandle_face_line(\n\t\t\t\t\t[ result[ 2 ], result[ 6 ], result[ 10 ], result[ 14 ] ], //faces\n\t\t\t\t\t[ result[ 3 ], result[ 7 ], result[ 11 ], result[ 15 ] ], //uv\n\t\t\t\t\t[ result[ 4 ], result[ 8 ], result[ 12 ], result[ 16 ] ] //normal\n\t\t\t\t);\n\n\t\t\t} else if ( ( result = face_pattern4.exec( line ) ) !== null ) {\n\n\t\t\t\t// [\"f 1//1 2//2 3//3\", \" 1//1\", \"1\", \"1\", \" 2//2\", \"2\", \"2\", \" 3//3\", \"3\", \"3\", undefined, undefined, undefined]\n\n\t\t\t\thandle_face_line(\n\t\t\t\t\t[ result[ 2 ], result[ 5 ], result[ 8 ], result[ 11 ] ], //faces\n\t\t\t\t\t[ ], //uv\n\t\t\t\t\t[ result[ 3 ], result[ 6 ], result[ 9 ], result[ 12 ] ] //normal\n\t\t\t\t);\n\n\t\t\t} else if ( /^o /.test( line ) ) {\n\n\t\t\t\t// object\n\n\t\t\t\tmeshN();\n\t\t\t\tface_offset = face_offset + vertices.length;\n\t\t\t\tvertices = [];\n\t\t\t\tobject = new THREE.Object3D();\n\t\t\t\tobject.name = line.substring( 2 ).trim();\n\t\t\t\tgroup.add( object );\n\n\t\t\t} else if ( /^g /.test( line ) ) {\n\n\t\t\t\t// group\n\n\t\t\t\tmeshN( line.substring( 2 ).trim(), undefined );\n\n\t\t\t} else if ( /^usemtl /.test( line ) ) {\n\n\t\t\t\t// material\n\n\t\t\t\tmeshN( undefined, line.substring( 7 ).trim() );\n\n\t\t\t} else if ( /^mtllib /.test( line ) ) {\n\n\t\t\t\t// mtl file\n\n\t\t\t\tif ( mtllibCallback ) {\n\n\t\t\t\t\tvar mtlfile = line.substring( 7 );\n\t\t\t\t\tmtlfile = mtlfile.trim();\n\t\t\t\t\tmtllibCallback( mtlfile );\n\n\t\t\t\t}\n\n\t\t\t} else if ( /^s /.test( line ) ) {\n\n\t\t\t\t// Smooth shading\n\n\t\t\t} else {\n\n\t\t\t\tconsole.log( \"THREE.OBJMTLLoader: Unhandled line \" + line );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//Add last object\n\t\tmeshN(undefined, undefined);\n\n\t\treturn group;\n\n\t}\n\n};\n\nTHREE.EventDispatcher.prototype.apply( THREE.OBJMTLLoader.prototype );"],"names":["THREE","OBJMTLLoader","manager","undefined","DefaultLoadingManager","prototype","constructor","load","url","mtlurl","onLoad","onProgress","onError","scope","mtlLoader","MTLLoader","substr","lastIndexOf","crossOrigin","materials","materialsCreator","preload","loader","XHRLoader","setCrossOrigin","text","object","parse","traverse","Mesh","material","name","create","data","mtllibCallback","vector","x","y","z","Vector3","face3","a","b","c","normals","Face3","face_offset","meshN","meshName","materialName","vertices","length","geometry","mergeVertices","computeFaceNormals","computeBoundingSphere","add","mesh","Geometry","MeshLambertMaterial","group","Group","uvs","add_face","normals_inds","faces","push","parseInt","clone","add_uvs","faceVertexUvs","handle_face_line","vertex_pattern","normal_pattern","uv_pattern","face_pattern1","face_pattern2","face_pattern3","face_pattern4","lines","split","i","u","v","result","line","trim","charAt","exec","parseFloat","Vector2","test","Object3D","substring","mtlfile","console","log","EventDispatcher","apply"],"version":3,"file":"index.729a327b.js.map"}