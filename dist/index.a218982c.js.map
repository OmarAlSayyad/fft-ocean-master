{"mappings":"ACOA,MAAM,SAAS,CAAC,KAAQ,CAAG,CAC1B,SAAU,CACT,QAAW,CAAE,KAAM,IAAK,MAAO,IAAI,EACnC,KAAQ,CAAE,KAAM,IAAK,MAAO,CAAE,EAC9B,MAAS,CAAE,KAAM,IAAK,MAAO,EAAI,EACjC,MAAS,CAAE,KAAM,IAAK,MAAO,EAAI,EACjC,OAAU,CAAE,KAAM,IAAK,MAAO,CAAE,EAChC,MAAS,CAAE,KAAM,IAAK,MAAO,CAAE,CAChC,EACA,aAAc,+KAWd,eAAgB,k+BA+EjB","sources":["<anon>","js/shaders/CloudShader2.js"],"sourcesContent":["\"use strict\";\n/**\n * Cloud shader by @blurspline / http://github.com/zz85\n * Refactored by @jbouny\n */ THREE.ShaderLib[\"cloud\"] = {\n    uniforms: {\n        \"texture\": {\n            type: \"t\",\n            value: null\n        },\n        \"time\": {\n            type: \"f\",\n            value: 1\n        },\n        \"sharp\": {\n            type: \"f\",\n            value: 0.9\n        },\n        \"cover\": {\n            type: \"f\",\n            value: 0.5\n        },\n        \"clouds\": {\n            type: \"f\",\n            value: 1\n        },\n        \"depth\": {\n            type: \"f\",\n            value: 0\n        }\n    },\n    vertexShader: [\n        \"uniform sampler2D texture;\",\n        \"uniform float time;\",\n        \"varying vec2 vUv;\",\n        \"void main()\",\n        \"{\",\n        \"vUv = uv;\",\n        \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n        \"}\"\n    ].join(\"\\n\"),\n    fragmentShader: [\n        // Cloud shader by @blurspline / http://github.com/zz85\n        // uses a simple fractal noise used a generated value-noise texture\n        // references\n        // 1. value noise\n        // 2. iq clouds\n        // 3. cloud papers\n        \"uniform float time;\",\n        \"uniform float depth;\",\n        \"uniform float sharp;\",\n        // 1 = dull ( more clouds), 0 = fuzzy ( less clouds)\n        \"uniform float cover;\",\n        // substraction factor\n        \"uniform float clouds;\",\n        \"uniform sampler2D texture;\",\n        \"varying vec2 vUv;\",\n        // multi-chanel noise lookup\n        \"vec3 noise3(vec2 p) {\",\n        \"\treturn texture2D(texture, p).xyz;\",\n        \"}\",\n        \"vec3 fNoise(vec2 uv) {\",\n        \"\tvec3 f = vec3(0.);\",\n        \"\tfloat scale = 1.;\",\n        \"\tfor (int i=0; i<5; i++) {\",\n        \"\t\tscale *= 2.;\",\n        \"\t\tf += noise3(uv * scale) / scale;\",\n        \"\t}\",\n        \"\treturn f;\",\n        \"}\",\n        \"void main(void)\",\n        \"{\",\n        \"\tvec2 uv = vUv;\",\n        // Formula: varience (smaller -> bigger cover) + speed (time) * direction\n        // normal thick clouds\n        \"\tvec3 ff1 = fNoise(uv * 0.01 + time * 0.00015 * vec2(-1., 1.));\",\n        // fast small clouds\n        \"\tvec3 ff2 = fNoise(uv * 0.1 + time * 0.0005 * vec2(1., 1.));\",\n        // Different combinations of mixing\n        \"\tfloat t = ff1.x * 0.9 + ff1.y * 0.15;\",\n        \"\tt = t * 0.99 + ff2.x * 0.01;\",\n        \"\tfloat o = clamp ( length(uv * 2.0 - vec2(1., 1.)), 0., 1. );\",\n        // applies more transparency to horizon for \n        // to create illusion of distant clouds\n        \"\to =  1. - o * o * o * o;\",\n        // multiply by more cloud transparency\n        \"\to -= (1. - t) * 0.95;\",\n        // 1 t = 1 o\n        // depending on where this is placed, it will affect darkness / opacity of clouds\n        \"\tt = max(t - (1. - cover), 0.);\",\n        // magnify or add layers!\n        // cloud power magnifer\n        \"\tt = 1. - pow(1. - sharp, t);\",\n        \"\tt = min(t * 1.9, 1.0);\",\n        // Other effects\n        \"\tif (depth > 0.) {\",\n        // tweak thresholds\n        \"\t\tif (o < 0.4 && t < 0.8) discard;\",\n        \"\t\tgl_FragData[ 0 ] = vec4(gl_FragCoord.z, 1., 1., 1.);\",\n        \"\t}\",\n        \"\telse {\",\n        \"\t\tgl_FragData[ 0 ] = vec4(t, t, t, o );\",\n        \"\t}\",\n        \"}\"\n    ].join(\"\\n\")\n};\nfunction CloudShader(renderer, noiseSize) {\n    noiseSize = noiseSize || 256;\n    var cloudShader = THREE.ShaderLib[\"cloud\"];\n    // Generate random noise texture\n    var size = noiseSize * noiseSize;\n    var data = new Uint8Array(4 * size);\n    for(var i = 0; i < size * 4; i++)data[i] = Math.random() * 255 | 0;\n    var dt = new THREE.DataTexture(data, noiseSize, noiseSize, THREE.RGBAFormat);\n    dt.wrapS = THREE.RepeatWrapping;\n    dt.wrapT = THREE.RepeatWrapping;\n    dt.magFilter = THREE.LinearFilter;\n    dt.minFilter = THREE.LinearFilter;\n    dt.needsUpdate = true;\n    cloudShader.uniforms.texture.value = dt;\n    var noiseMaterial = new THREE.ShaderMaterial({\n        vertexShader: cloudShader.vertexShader,\n        fragmentShader: cloudShader.fragmentShader,\n        uniforms: cloudShader.uniforms,\n        side: THREE.DoubleSide,\n        transparent: true\n    });\n    this.noiseMaterial = noiseMaterial;\n    var scamera, sscene, smesh;\n    scamera = new THREE.Camera();\n    scamera.position.z = 1;\n    sscene = new THREE.Scene();\n    smesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), noiseMaterial);\n    sscene.add(smesh);\n    function SkyDome(i, j) {\n        i -= 0.5;\n        j -= 0.5;\n        var r2 = i * i * 4 + j * j * 4;\n        var scale = 100000;\n        return new THREE.Vector3(i * 20 * scale, (1 - r2) * 5 * scale, j * 20 * scale).multiplyScalar(0.05);\n    }\n    this.cloudMesh = new THREE.Mesh(new THREE.ParametricGeometry(SkyDome, 5, 5), noiseMaterial);\n    var performance = window.performance || Date;\n    function update() {\n        noiseMaterial.uniforms.time.value = performance.now() / 1000;\n    }\n    this.update = update;\n    this.depthOnly = function(v) {\n        noiseMaterial.uniforms.depth.value = v ? 1 : 0;\n    };\n}\n\n//# sourceMappingURL=index.a218982c.js.map\n","\"use strict\";\n\n/**\n * Cloud shader by @blurspline / http://github.com/zz85\n * Refactored by @jbouny\n */\n\nTHREE.ShaderLib['cloud'] = {\n\tuniforms: {\n\t\t'texture': { type: 't', value: null},\n\t\t'time': { type: 'f', value: 1 },\n\t\t'sharp': { type: 'f', value: 0.9 },\n\t\t'cover': { type: 'f', value: 0.5 },\n\t\t'clouds': { type: 'f', value: 1 },\n\t\t'depth': { type: 'f', value: 0 }\n\t},\n\tvertexShader: [\n\t\t'uniform sampler2D texture;',\n\t\t'uniform float time;',\n\t\t'varying vec2 vUv;',\n\t\t\n\t\t'void main()',\n\t\t'{',\n\t\t\t'vUv = uv;',\n\t\t'\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\t\t'}'\n\t].join('\\n'),\n\tfragmentShader: [\n\t\t// Cloud shader by @blurspline / http://github.com/zz85\n\t\t// uses a simple fractal noise used a generated value-noise texture\n\n\t\t// references\n\t\t// 1. value noise\n\t\t// 2. iq clouds\n\t\t// 3. cloud papers\n\t\t'uniform float time;',\n\n\t\t'uniform float depth;',\n\t\t'uniform float sharp;', // magnify the intensity of clouds\n\t\t// 1 = dull ( more clouds), 0 = fuzzy ( less clouds)\n\t\t'uniform float cover;', // 0 = less clouds, 1 = more clouds\n\t\t\t\t\t\t\t// substraction factor\n\t\t'uniform float clouds;', // opacity\n\t\t'uniform sampler2D texture;',\n\t\t'varying vec2 vUv;',\n\n\t\t// multi-chanel noise lookup\n\t\t'vec3 noise3(vec2 p) {',\n\t\t'\treturn texture2D(texture, p).xyz;',\n\t\t'}',\n\n\t\t'vec3 fNoise(vec2 uv) {',\n\t\t'\tvec3 f = vec3(0.);',\n\t\t'\tfloat scale = 1.;',\n\t\t'\tfor (int i=0; i<5; i++) {',\n\t\t'\t\tscale *= 2.;',\n\t\t'\t\tf += noise3(uv * scale) / scale;',\n\t\t'\t}',\n\t\t'\treturn f;',\n\t\t'}',\n\n\t\t'void main(void)',\n\t\t'{',\n\t\t'\tvec2 uv = vUv;',\n\t\t\t\n\t\t\t// Formula: varience (smaller -> bigger cover) + speed (time) * direction\n\t\t\t// normal thick clouds\n\t\t'\tvec3 ff1 = fNoise(uv * 0.01 + time * 0.00015 * vec2(-1., 1.));',\n\n\t\t\t// fast small clouds\n\t\t'\tvec3 ff2 = fNoise(uv * 0.1 + time * 0.0005 * vec2(1., 1.));',\n\t\t\t\n\t\t\t// Different combinations of mixing\n\t\t'\tfloat t = ff1.x * 0.9 + ff1.y * 0.15;',\n\t\t'\tt = t * 0.99 + ff2.x * 0.01;',\n\n\t\t'\tfloat o = clamp ( length(uv * 2.0 - vec2(1., 1.)), 0., 1. );',\n\t\t\t\n\t\t\t// applies more transparency to horizon for \n\t\t\t// to create illusion of distant clouds\n\t\t'\to =  1. - o * o * o * o;',\n\n\t\t\t// multiply by more cloud transparency\n\t\t'\to -= (1. - t) * 0.95;', // factor clouds opacity based on cloud cover\n\t\t\t// 1 t = 1 o\n\t\t\t// depending on where this is placed, it will affect darkness / opacity of clouds\n\t\t'\tt = max(t - (1. - cover), 0.);', // low cut off point\n\t\t\t// magnify or add layers!\n\t\t\t// cloud power magnifer\n\t\t'\tt = 1. - pow(1. - sharp, t);', // . 0.999999 (response curve from linear to exponiential brigtness)\n\t\t'\tt = min(t * 1.9, 1.0);', // clamp to 1.0\n\n\t\t\t// Other effects\n\n\t\t'\tif (depth > 0.) {',\n\t\t\t\t// tweak thresholds\n\t\t'\t\tif (o < 0.4 && t < 0.8) discard;',\n\n\t\t'\t\tgl_FragData[ 0 ] = vec4(gl_FragCoord.z, 1., 1., 1.);',\n\t\t'\t}',\n\t\t'\telse {',\n\t\t'\t\tgl_FragData[ 0 ] = vec4(t, t, t, o );',\n\n\t\t'\t}',\t\t\t\n\t\t'}'\n\t].join('\\n')\n};\n\nfunction CloudShader( renderer, noiseSize ) {\n\n\tnoiseSize = noiseSize || 256;\n\t\n\tvar cloudShader = THREE.ShaderLib['cloud'] ;\n\n\t// Generate random noise texture\n\tvar size = noiseSize * noiseSize;\n\tvar data = new Uint8Array( 4 * size );\n\n\tfor ( var i = 0; i < size * 4; i ++ ) {\n\t\tdata[ i ] = Math.random() * 255 | 0;\n\t}\n\n\tvar dt = new THREE.DataTexture( data, noiseSize, noiseSize, THREE.RGBAFormat );\n\tdt.wrapS = THREE.RepeatWrapping;\n\tdt.wrapT = THREE.RepeatWrapping;\n\tdt.magFilter = THREE.LinearFilter;\n\tdt.minFilter = THREE.LinearFilter;\n\tdt.needsUpdate = true;\n\t\n\tcloudShader.uniforms.texture.value = dt;\n\n\tvar noiseMaterial = new THREE.ShaderMaterial({\n\t\tvertexShader: cloudShader.vertexShader,\n\t\tfragmentShader: cloudShader.fragmentShader,\n\t\tuniforms: cloudShader.uniforms,\n\t\tside: THREE.DoubleSide,\n\t\ttransparent: true\n\t});\n\n\tthis.noiseMaterial = noiseMaterial;\n\n\tvar scamera, sscene, smesh;\n\n\tscamera = new THREE.Camera();\n\n\tscamera.position.z = 1;\n\n\tsscene = new THREE.Scene();\n\n\tsmesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), noiseMaterial );\n\n\tsscene.add(smesh);\n\n\tfunction SkyDome(i, j) {\n\t\ti -= 0.5;\n\t\tj -= 0.5;\n\n\t\tvar r2 = i * i * 4 + j * j * 4;\n\t\tvar scale = 100000;\n\n\t\treturn new THREE.Vector3(\n\t\t\ti * 20 * scale,\n\t\t\t(1 - r2) * 5 * scale,\n\t\t\tj * 20 * scale\n\t\t).multiplyScalar(0.05);\n\n\t};\n\n\tthis.cloudMesh = new THREE.Mesh( \n\t\tnew THREE.ParametricGeometry(SkyDome, 5, 5),\n\t\tnoiseMaterial\n\t);\n\n\tvar performance = window.performance || Date;\n\n\tfunction update() {\n\t\tnoiseMaterial.uniforms.time.value = performance.now() / 1000;\n\t}\n\tthis.update = update;\n\n\tthis.depthOnly = function(v) {\n\t\tnoiseMaterial.uniforms.depth.value = v ? 1 : 0;\n\t};\n\n}\n"],"names":["THREE","ShaderLib","uniforms","type","value","vertexShader","fragmentShader"],"version":3,"file":"index.a218982c.js.map"}