{"mappings":"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","sources":["<anon>","js/controls/OrbitControls.js"],"sourcesContent":["/**\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n */ /*global THREE, console */ // This set of controls performs orbiting, dollying (zooming), and panning. It maintains\n// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\n// supported.\n//\n//    Orbit - left mouse / touch: one finger move\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\nTHREE.OrbitControls = function(object, domElement) {\n    this.object = object;\n    this.domElement = domElement !== undefined ? domElement : document;\n    // API\n    // Set to false to disable this control\n    this.enabled = true;\n    // \"target\" sets the location of focus, where the control orbits around\n    // and where it pans with respect to.\n    this.target = new THREE.Vector3();\n    // center is old, deprecated; use \"target\" instead\n    this.center = this.target;\n    // This option actually enables dollying in and out; left as \"zoom\" for\n    // backwards compatibility\n    this.noZoom = false;\n    this.zoomSpeed = 1.0;\n    // Limits to how far you can dolly in and out ( PerspectiveCamera only )\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n    // Limits to how far you can zoom in and out ( OrthographicCamera only )\n    this.minZoom = 0;\n    this.maxZoom = Infinity;\n    // Set to true to disable this control\n    this.noRotate = false;\n    this.rotateSpeed = 1.0;\n    // Set to true to disable this control\n    this.noPan = false;\n    this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n    // Set to true to automatically rotate around the target\n    this.autoRotate = false;\n    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n    // How far you can orbit vertically, upper and lower limits.\n    // Range is 0 to Math.PI radians.\n    this.minPolarAngle = 0; // radians\n    this.maxPolarAngle = Math.PI; // radians\n    // How far you can orbit horizontally, upper and lower limits.\n    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n    this.minAzimuthAngle = -Infinity; // radians\n    this.maxAzimuthAngle = Infinity; // radians\n    // Set to true to disable use of the keys\n    this.noKeys = false;\n    // The four arrow keys\n    this.keys = {\n        LEFT: 37,\n        UP: 38,\n        RIGHT: 39,\n        BOTTOM: 40\n    };\n    // Mouse buttons\n    this.mouseButtons = {\n        ORBIT: THREE.MOUSE.LEFT,\n        ZOOM: THREE.MOUSE.MIDDLE,\n        PAN: THREE.MOUSE.RIGHT\n    };\n    ////////////\n    // internals\n    var scope = this;\n    var EPS = 0.000001;\n    var rotateStart = new THREE.Vector2();\n    var rotateEnd = new THREE.Vector2();\n    var rotateDelta = new THREE.Vector2();\n    var panStart = new THREE.Vector2();\n    var panEnd = new THREE.Vector2();\n    var panDelta = new THREE.Vector2();\n    var panOffset = new THREE.Vector3();\n    var offset = new THREE.Vector3();\n    var dollyStart = new THREE.Vector2();\n    var dollyEnd = new THREE.Vector2();\n    var dollyDelta = new THREE.Vector2();\n    var theta;\n    var phi;\n    var phiDelta = 0;\n    var thetaDelta = 0;\n    var scale = 1;\n    var pan = new THREE.Vector3();\n    var lastPosition = new THREE.Vector3();\n    var lastQuaternion = new THREE.Quaternion();\n    var STATE = {\n        NONE: -1,\n        ROTATE: 0,\n        DOLLY: 1,\n        PAN: 2,\n        TOUCH_ROTATE: 3,\n        TOUCH_DOLLY: 4,\n        TOUCH_PAN: 5\n    };\n    var state = STATE.NONE;\n    // for reset\n    this.target0 = this.target.clone();\n    this.position0 = this.object.position.clone();\n    this.zoom0 = this.object.zoom;\n    // so camera.up is the orbit axis\n    var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));\n    var quatInverse = quat.clone().inverse();\n    // events\n    var changeEvent = {\n        type: \"change\"\n    };\n    var startEvent = {\n        type: \"start\"\n    };\n    var endEvent = {\n        type: \"end\"\n    };\n    this.rotateLeft = function(angle) {\n        if (angle === undefined) angle = getAutoRotationAngle();\n        thetaDelta -= angle;\n    };\n    this.rotateUp = function(angle) {\n        if (angle === undefined) angle = getAutoRotationAngle();\n        phiDelta -= angle;\n    };\n    // pass in distance in world space to move left\n    this.panLeft = function(distance) {\n        var te = this.object.matrix.elements;\n        // get X column of matrix\n        panOffset.set(te[0], te[1], te[2]);\n        panOffset.multiplyScalar(-distance);\n        pan.add(panOffset);\n    };\n    // pass in distance in world space to move up\n    this.panUp = function(distance) {\n        var te = this.object.matrix.elements;\n        // get Y column of matrix\n        panOffset.set(te[4], te[5], te[6]);\n        panOffset.multiplyScalar(distance);\n        pan.add(panOffset);\n    };\n    // pass in x,y of change desired in pixel space,\n    // right and down are positive\n    this.pan = function(deltaX, deltaY) {\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n        if (scope.object instanceof THREE.PerspectiveCamera) {\n            // perspective\n            var position = scope.object.position;\n            var offset = position.clone().sub(scope.target);\n            var targetDistance = offset.length();\n            // half of the fov is center to top of screen\n            targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0);\n            // we actually don't use screenWidth, since perspective camera is fixed to screen height\n            scope.panLeft(2 * deltaX * targetDistance / element.clientHeight);\n            scope.panUp(2 * deltaY * targetDistance / element.clientHeight);\n        } else if (scope.object instanceof THREE.OrthographicCamera) {\n            // orthographic\n            scope.panLeft(deltaX * (scope.object.right - scope.object.left) / element.clientWidth);\n            scope.panUp(deltaY * (scope.object.top - scope.object.bottom) / element.clientHeight);\n        } else // camera neither orthographic or perspective\n        console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.\");\n    };\n    this.dollyIn = function(dollyScale) {\n        if (dollyScale === undefined) dollyScale = getZoomScale();\n        if (scope.object instanceof THREE.PerspectiveCamera) scale /= dollyScale;\n        else if (scope.object instanceof THREE.OrthographicCamera) {\n            scope.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom * dollyScale));\n            scope.object.updateProjectionMatrix();\n            scope.dispatchEvent(changeEvent);\n        } else console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\");\n    };\n    this.dollyOut = function(dollyScale) {\n        if (dollyScale === undefined) dollyScale = getZoomScale();\n        if (scope.object instanceof THREE.PerspectiveCamera) scale *= dollyScale;\n        else if (scope.object instanceof THREE.OrthographicCamera) {\n            scope.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / dollyScale));\n            scope.object.updateProjectionMatrix();\n            scope.dispatchEvent(changeEvent);\n        } else console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\");\n    };\n    this.update = function() {\n        var position = this.object.position;\n        offset.copy(position).sub(this.target);\n        // rotate offset to \"y-axis-is-up\" space\n        offset.applyQuaternion(quat);\n        // angle from z-axis around y-axis\n        theta = Math.atan2(offset.x, offset.z);\n        // angle from y-axis\n        phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);\n        if (this.autoRotate && state === STATE.NONE) this.rotateLeft(getAutoRotationAngle());\n        theta += thetaDelta;\n        phi += phiDelta;\n        // restrict theta to be between desired limits\n        theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, theta));\n        // restrict phi to be between desired limits\n        phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));\n        // restrict phi to be betwee EPS and PI-EPS\n        phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));\n        var radius = offset.length() * scale;\n        // restrict radius to be between desired limits\n        radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));\n        // move target to panned location\n        this.target.add(pan);\n        offset.x = radius * Math.sin(phi) * Math.sin(theta);\n        offset.y = radius * Math.cos(phi);\n        offset.z = radius * Math.sin(phi) * Math.cos(theta);\n        // rotate offset back to \"camera-up-vector-is-up\" space\n        offset.applyQuaternion(quatInverse);\n        position.copy(this.target).add(offset);\n        this.object.lookAt(this.target);\n        thetaDelta = 0;\n        phiDelta = 0;\n        scale = 1;\n        pan.set(0, 0, 0);\n        // update condition is:\n        // min(camera displacement, camera rotation in radians)^2 > EPS\n        // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n        if (lastPosition.distanceToSquared(this.object.position) > EPS || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS) {\n            this.dispatchEvent(changeEvent);\n            lastPosition.copy(this.object.position);\n            lastQuaternion.copy(this.object.quaternion);\n        }\n    };\n    this.reset = function() {\n        state = STATE.NONE;\n        this.target.copy(this.target0);\n        this.object.position.copy(this.position0);\n        this.object.zoom = this.zoom0;\n        this.object.updateProjectionMatrix();\n        this.dispatchEvent(changeEvent);\n        this.update();\n    };\n    this.getPolarAngle = function() {\n        return phi;\n    };\n    this.getAzimuthalAngle = function() {\n        return theta;\n    };\n    function getAutoRotationAngle() {\n        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n    }\n    function getZoomScale() {\n        return Math.pow(0.95, scope.zoomSpeed);\n    }\n    function onMouseDown(event) {\n        if (scope.enabled === false) return;\n        event.preventDefault();\n        if (event.button === scope.mouseButtons.ORBIT) {\n            if (scope.noRotate === true) return;\n            state = STATE.ROTATE;\n            rotateStart.set(event.clientX, event.clientY);\n        } else if (event.button === scope.mouseButtons.ZOOM) {\n            if (scope.noZoom === true) return;\n            state = STATE.DOLLY;\n            dollyStart.set(event.clientX, event.clientY);\n        } else if (event.button === scope.mouseButtons.PAN) {\n            if (scope.noPan === true) return;\n            state = STATE.PAN;\n            panStart.set(event.clientX, event.clientY);\n        }\n        if (state !== STATE.NONE) {\n            document.addEventListener(\"mousemove\", onMouseMove, false);\n            document.addEventListener(\"mouseup\", onMouseUp, false);\n            scope.dispatchEvent(startEvent);\n        }\n    }\n    function onMouseMove(event) {\n        if (scope.enabled === false) return;\n        event.preventDefault();\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n        if (state === STATE.ROTATE) {\n            if (scope.noRotate === true) return;\n            rotateEnd.set(event.clientX, event.clientY);\n            rotateDelta.subVectors(rotateEnd, rotateStart);\n            // rotating across whole screen goes 360 degrees around\n            scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n            // rotating up and down along whole screen attempts to go 360, but limited to 180\n            scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n            rotateStart.copy(rotateEnd);\n        } else if (state === STATE.DOLLY) {\n            if (scope.noZoom === true) return;\n            dollyEnd.set(event.clientX, event.clientY);\n            dollyDelta.subVectors(dollyEnd, dollyStart);\n            if (dollyDelta.y > 0) scope.dollyIn();\n            else if (dollyDelta.y < 0) scope.dollyOut();\n            dollyStart.copy(dollyEnd);\n        } else if (state === STATE.PAN) {\n            if (scope.noPan === true) return;\n            panEnd.set(event.clientX, event.clientY);\n            panDelta.subVectors(panEnd, panStart);\n            scope.pan(panDelta.x, panDelta.y);\n            panStart.copy(panEnd);\n        }\n        if (state !== STATE.NONE) scope.update();\n    }\n    function onMouseUp() {\n        if (scope.enabled === false) return;\n        document.removeEventListener(\"mousemove\", onMouseMove, false);\n        document.removeEventListener(\"mouseup\", onMouseUp, false);\n        scope.dispatchEvent(endEvent);\n        state = STATE.NONE;\n    }\n    function onMouseWheel(event) {\n        if (scope.enabled === false || scope.noZoom === true || state !== STATE.NONE) return;\n        event.preventDefault();\n        event.stopPropagation();\n        var delta = 0;\n        if (event.wheelDelta !== undefined) delta = event.wheelDelta;\n        else if (event.detail !== undefined) delta = -event.detail;\n        if (delta > 0) scope.dollyOut();\n        else if (delta < 0) scope.dollyIn();\n        scope.update();\n        scope.dispatchEvent(startEvent);\n        scope.dispatchEvent(endEvent);\n    }\n    function onKeyDown(event) {\n        if (scope.enabled === false || scope.noKeys === true || scope.noPan === true) return;\n        switch(event.keyCode){\n            case scope.keys.UP:\n                scope.pan(0, scope.keyPanSpeed);\n                scope.update();\n                break;\n            case scope.keys.BOTTOM:\n                scope.pan(0, -scope.keyPanSpeed);\n                scope.update();\n                break;\n            case scope.keys.LEFT:\n                scope.pan(scope.keyPanSpeed, 0);\n                scope.update();\n                break;\n            case scope.keys.RIGHT:\n                scope.pan(-scope.keyPanSpeed, 0);\n                scope.update();\n                break;\n        }\n    }\n    function touchstart(event) {\n        if (scope.enabled === false) return;\n        switch(event.touches.length){\n            case 1:\n                if (scope.noRotate === true) return;\n                state = STATE.TOUCH_ROTATE;\n                rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n                break;\n            case 2:\n                if (scope.noZoom === true) return;\n                state = STATE.TOUCH_DOLLY;\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                var distance = Math.sqrt(dx * dx + dy * dy);\n                dollyStart.set(0, distance);\n                break;\n            case 3:\n                if (scope.noPan === true) return;\n                state = STATE.TOUCH_PAN;\n                panStart.set(event.touches[0].pageX, event.touches[0].pageY);\n                break;\n            default:\n                state = STATE.NONE;\n        }\n        if (state !== STATE.NONE) scope.dispatchEvent(startEvent);\n    }\n    function touchmove(event) {\n        if (scope.enabled === false) return;\n        event.preventDefault();\n        event.stopPropagation();\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n        switch(event.touches.length){\n            case 1:\n                if (scope.noRotate === true) return;\n                if (state !== STATE.TOUCH_ROTATE) return;\n                rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                rotateDelta.subVectors(rotateEnd, rotateStart);\n                // rotating across whole screen goes 360 degrees around\n                scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n                // rotating up and down along whole screen attempts to go 360, but limited to 180\n                scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n                rotateStart.copy(rotateEnd);\n                scope.update();\n                break;\n            case 2:\n                if (scope.noZoom === true) return;\n                if (state !== STATE.TOUCH_DOLLY) return;\n                var dx = event.touches[0].pageX - event.touches[1].pageX;\n                var dy = event.touches[0].pageY - event.touches[1].pageY;\n                var distance = Math.sqrt(dx * dx + dy * dy);\n                dollyEnd.set(0, distance);\n                dollyDelta.subVectors(dollyEnd, dollyStart);\n                if (dollyDelta.y > 0) scope.dollyOut();\n                else if (dollyDelta.y < 0) scope.dollyIn();\n                dollyStart.copy(dollyEnd);\n                scope.update();\n                break;\n            case 3:\n                if (scope.noPan === true) return;\n                if (state !== STATE.TOUCH_PAN) return;\n                panEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n                panDelta.subVectors(panEnd, panStart);\n                scope.pan(panDelta.x, panDelta.y);\n                panStart.copy(panEnd);\n                scope.update();\n                break;\n            default:\n                state = STATE.NONE;\n        }\n    }\n    function touchend() {\n        if (scope.enabled === false) return;\n        scope.dispatchEvent(endEvent);\n        state = STATE.NONE;\n    }\n    this.domElement.addEventListener(\"contextmenu\", function(event) {\n        event.preventDefault();\n    }, false);\n    this.domElement.addEventListener(\"mousedown\", onMouseDown, false);\n    this.domElement.addEventListener(\"mousewheel\", onMouseWheel, false);\n    this.domElement.addEventListener(\"DOMMouseScroll\", onMouseWheel, false); // firefox\n    this.domElement.addEventListener(\"touchstart\", touchstart, false);\n    this.domElement.addEventListener(\"touchend\", touchend, false);\n    this.domElement.addEventListener(\"touchmove\", touchmove, false);\n    window.addEventListener(\"keydown\", onKeyDown, false);\n    // force an update at start\n    this.update();\n};\nTHREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);\nTHREE.OrbitControls.prototype.constructor = THREE.OrbitControls;\n\n//# sourceMappingURL=index.98dba674.js.map\n","/**\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n */\n/*global THREE, console */\n\n// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\n// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\n// supported.\n//\n//    Orbit - left mouse / touch: one finger move\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\n\nTHREE.OrbitControls = function ( object, domElement ) {\n\n\tthis.object = object;\n\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\n\n\t// API\n\n\t// Set to false to disable this control\n\tthis.enabled = true;\n\n\t// \"target\" sets the location of focus, where the control orbits around\n\t// and where it pans with respect to.\n\tthis.target = new THREE.Vector3();\n\n\t// center is old, deprecated; use \"target\" instead\n\tthis.center = this.target;\n\n\t// This option actually enables dollying in and out; left as \"zoom\" for\n\t// backwards compatibility\n\tthis.noZoom = false;\n\tthis.zoomSpeed = 1.0;\n\n\t// Limits to how far you can dolly in and out ( PerspectiveCamera only )\n\tthis.minDistance = 0;\n\tthis.maxDistance = Infinity;\n\n\t// Limits to how far you can zoom in and out ( OrthographicCamera only )\n\tthis.minZoom = 0;\n\tthis.maxZoom = Infinity;\n\n\t// Set to true to disable this control\n\tthis.noRotate = false;\n\tthis.rotateSpeed = 1.0;\n\n\t// Set to true to disable this control\n\tthis.noPan = false;\n\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\n\n\t// Set to true to automatically rotate around the target\n\tthis.autoRotate = false;\n\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n\t// How far you can orbit vertically, upper and lower limits.\n\t// Range is 0 to Math.PI radians.\n\tthis.minPolarAngle = 0; // radians\n\tthis.maxPolarAngle = Math.PI; // radians\n\n\t// How far you can orbit horizontally, upper and lower limits.\n\t// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n\tthis.minAzimuthAngle = - Infinity; // radians\n\tthis.maxAzimuthAngle = Infinity; // radians\n\n\t// Set to true to disable use of the keys\n\tthis.noKeys = false;\n\n\t// The four arrow keys\n\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\n\n\t// Mouse buttons\n\tthis.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };\n\n\t////////////\n\t// internals\n\n\tvar scope = this;\n\n\tvar EPS = 0.000001;\n\n\tvar rotateStart = new THREE.Vector2();\n\tvar rotateEnd = new THREE.Vector2();\n\tvar rotateDelta = new THREE.Vector2();\n\n\tvar panStart = new THREE.Vector2();\n\tvar panEnd = new THREE.Vector2();\n\tvar panDelta = new THREE.Vector2();\n\tvar panOffset = new THREE.Vector3();\n\n\tvar offset = new THREE.Vector3();\n\n\tvar dollyStart = new THREE.Vector2();\n\tvar dollyEnd = new THREE.Vector2();\n\tvar dollyDelta = new THREE.Vector2();\n\n\tvar theta;\n\tvar phi;\n\tvar phiDelta = 0;\n\tvar thetaDelta = 0;\n\tvar scale = 1;\n\tvar pan = new THREE.Vector3();\n\n\tvar lastPosition = new THREE.Vector3();\n\tvar lastQuaternion = new THREE.Quaternion();\n\n\tvar STATE = { NONE : -1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };\n\n\tvar state = STATE.NONE;\n\n\t// for reset\n\n\tthis.target0 = this.target.clone();\n\tthis.position0 = this.object.position.clone();\n\tthis.zoom0 = this.object.zoom;\n\n\t// so camera.up is the orbit axis\n\n\tvar quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );\n\tvar quatInverse = quat.clone().inverse();\n\n\t// events\n\n\tvar changeEvent = { type: 'change' };\n\tvar startEvent = { type: 'start' };\n\tvar endEvent = { type: 'end' };\n\n\tthis.rotateLeft = function ( angle ) {\n\n\t\tif ( angle === undefined ) {\n\n\t\t\tangle = getAutoRotationAngle();\n\n\t\t}\n\n\t\tthetaDelta -= angle;\n\n\t};\n\n\tthis.rotateUp = function ( angle ) {\n\n\t\tif ( angle === undefined ) {\n\n\t\t\tangle = getAutoRotationAngle();\n\n\t\t}\n\n\t\tphiDelta -= angle;\n\n\t};\n\n\t// pass in distance in world space to move left\n\tthis.panLeft = function ( distance ) {\n\n\t\tvar te = this.object.matrix.elements;\n\n\t\t// get X column of matrix\n\t\tpanOffset.set( te[ 0 ], te[ 1 ], te[ 2 ] );\n\t\tpanOffset.multiplyScalar( - distance );\n\n\t\tpan.add( panOffset );\n\n\t};\n\n\t// pass in distance in world space to move up\n\tthis.panUp = function ( distance ) {\n\n\t\tvar te = this.object.matrix.elements;\n\n\t\t// get Y column of matrix\n\t\tpanOffset.set( te[ 4 ], te[ 5 ], te[ 6 ] );\n\t\tpanOffset.multiplyScalar( distance );\n\n\t\tpan.add( panOffset );\n\n\t};\n\n\t// pass in x,y of change desired in pixel space,\n\t// right and down are positive\n\tthis.pan = function ( deltaX, deltaY ) {\n\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\n\t\t\t// perspective\n\t\t\tvar position = scope.object.position;\n\t\t\tvar offset = position.clone().sub( scope.target );\n\t\t\tvar targetDistance = offset.length();\n\n\t\t\t// half of the fov is center to top of screen\n\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\n\n\t\t\t// we actually don't use screenWidth, since perspective camera is fixed to screen height\n\t\t\tscope.panLeft( 2 * deltaX * targetDistance / element.clientHeight );\n\t\t\tscope.panUp( 2 * deltaY * targetDistance / element.clientHeight );\n\n\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\n\t\t\t// orthographic\n\t\t\tscope.panLeft( deltaX * (scope.object.right - scope.object.left) / element.clientWidth );\n\t\t\tscope.panUp( deltaY * (scope.object.top - scope.object.bottom) / element.clientHeight );\n\n\t\t} else {\n\n\t\t\t// camera neither orthographic or perspective\n\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\n\n\t\t}\n\n\t};\n\n\tthis.dollyIn = function ( dollyScale ) {\n\n\t\tif ( dollyScale === undefined ) {\n\n\t\t\tdollyScale = getZoomScale();\n\n\t\t}\n\n\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\n\t\t\tscale /= dollyScale;\n\n\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\n\t\t\tscope.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom * dollyScale ) );\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tscope.dispatchEvent( changeEvent );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\n\t\t}\n\n\t};\n\n\tthis.dollyOut = function ( dollyScale ) {\n\n\t\tif ( dollyScale === undefined ) {\n\n\t\t\tdollyScale = getZoomScale();\n\n\t\t}\n\n\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\n\t\t\tscale *= dollyScale;\n\n\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\n\t\t\tscope.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom / dollyScale ) );\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tscope.dispatchEvent( changeEvent );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\n\t\t}\n\n\t};\n\n\tthis.update = function () {\n\n\t\tvar position = this.object.position;\n\n\t\toffset.copy( position ).sub( this.target );\n\n\t\t// rotate offset to \"y-axis-is-up\" space\n\t\toffset.applyQuaternion( quat );\n\n\t\t// angle from z-axis around y-axis\n\n\t\ttheta = Math.atan2( offset.x, offset.z );\n\n\t\t// angle from y-axis\n\n\t\tphi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );\n\n\t\tif ( this.autoRotate && state === STATE.NONE ) {\n\n\t\t\tthis.rotateLeft( getAutoRotationAngle() );\n\n\t\t}\n\n\t\ttheta += thetaDelta;\n\t\tphi += phiDelta;\n\n\t\t// restrict theta to be between desired limits\n\t\ttheta = Math.max( this.minAzimuthAngle, Math.min( this.maxAzimuthAngle, theta ) );\n\n\t\t// restrict phi to be between desired limits\n\t\tphi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );\n\n\t\t// restrict phi to be betwee EPS and PI-EPS\n\t\tphi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );\n\n\t\tvar radius = offset.length() * scale;\n\n\t\t// restrict radius to be between desired limits\n\t\tradius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );\n\n\t\t// move target to panned location\n\t\tthis.target.add( pan );\n\n\t\toffset.x = radius * Math.sin( phi ) * Math.sin( theta );\n\t\toffset.y = radius * Math.cos( phi );\n\t\toffset.z = radius * Math.sin( phi ) * Math.cos( theta );\n\n\t\t// rotate offset back to \"camera-up-vector-is-up\" space\n\t\toffset.applyQuaternion( quatInverse );\n\n\t\tposition.copy( this.target ).add( offset );\n\n\t\tthis.object.lookAt( this.target );\n\n\t\tthetaDelta = 0;\n\t\tphiDelta = 0;\n\t\tscale = 1;\n\t\tpan.set( 0, 0, 0 );\n\n\t\t// update condition is:\n\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\n\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n\t\tif ( lastPosition.distanceToSquared( this.object.position ) > EPS\n\t\t    || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS ) {\n\n\t\t\tthis.dispatchEvent( changeEvent );\n\n\t\t\tlastPosition.copy( this.object.position );\n\t\t\tlastQuaternion.copy (this.object.quaternion );\n\n\t\t}\n\n\t};\n\n\n\tthis.reset = function () {\n\n\t\tstate = STATE.NONE;\n\n\t\tthis.target.copy( this.target0 );\n\t\tthis.object.position.copy( this.position0 );\n\t\tthis.object.zoom = this.zoom0;\n\n\t\tthis.object.updateProjectionMatrix();\n\t\tthis.dispatchEvent( changeEvent );\n\n\t\tthis.update();\n\n\t};\n\n\tthis.getPolarAngle = function () {\n\n\t\treturn phi;\n\n\t};\n\n\tthis.getAzimuthalAngle = function () {\n\n\t\treturn theta\n\n\t};\n\n\tfunction getAutoRotationAngle() {\n\n\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n\t}\n\n\tfunction getZoomScale() {\n\n\t\treturn Math.pow( 0.95, scope.zoomSpeed );\n\n\t}\n\n\tfunction onMouseDown( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\t\tevent.preventDefault();\n\n\t\tif ( event.button === scope.mouseButtons.ORBIT ) {\n\t\t\tif ( scope.noRotate === true ) return;\n\n\t\t\tstate = STATE.ROTATE;\n\n\t\t\trotateStart.set( event.clientX, event.clientY );\n\n\t\t} else if ( event.button === scope.mouseButtons.ZOOM ) {\n\t\t\tif ( scope.noZoom === true ) return;\n\n\t\t\tstate = STATE.DOLLY;\n\n\t\t\tdollyStart.set( event.clientX, event.clientY );\n\n\t\t} else if ( event.button === scope.mouseButtons.PAN ) {\n\t\t\tif ( scope.noPan === true ) return;\n\n\t\t\tstate = STATE.PAN;\n\n\t\t\tpanStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tif ( state !== STATE.NONE ) {\n\t\t\tdocument.addEventListener( 'mousemove', onMouseMove, false );\n\t\t\tdocument.addEventListener( 'mouseup', onMouseUp, false );\n\t\t\tscope.dispatchEvent( startEvent );\n\t\t}\n\n\t}\n\n\tfunction onMouseMove( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\tif ( state === STATE.ROTATE ) {\n\n\t\t\tif ( scope.noRotate === true ) return;\n\n\t\t\trotateEnd.set( event.clientX, event.clientY );\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\n\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\tscope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\n\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\tscope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t} else if ( state === STATE.DOLLY ) {\n\n\t\t\tif ( scope.noZoom === true ) return;\n\n\t\t\tdollyEnd.set( event.clientX, event.clientY );\n\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\tscope.dollyIn();\n\n\t\t\t} else if ( dollyDelta.y < 0 ) {\n\n\t\t\t\tscope.dollyOut();\n\n\t\t\t}\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t} else if ( state === STATE.PAN ) {\n\n\t\t\tif ( scope.noPan === true ) return;\n\n\t\t\tpanEnd.set( event.clientX, event.clientY );\n\t\t\tpanDelta.subVectors( panEnd, panStart );\n\n\t\t\tscope.pan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t}\n\n\t\tif ( state !== STATE.NONE ) scope.update();\n\n\t}\n\n\tfunction onMouseUp( /* event */ ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\n\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\n\t\tscope.dispatchEvent( endEvent );\n\t\tstate = STATE.NONE;\n\n\t}\n\n\tfunction onMouseWheel( event ) {\n\n\t\tif ( scope.enabled === false || scope.noZoom === true || state !== STATE.NONE ) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tvar delta = 0;\n\n\t\tif ( event.wheelDelta !== undefined ) { // WebKit / Opera / Explorer 9\n\n\t\t\tdelta = event.wheelDelta;\n\n\t\t} else if ( event.detail !== undefined ) { // Firefox\n\n\t\t\tdelta = - event.detail;\n\n\t\t}\n\n\t\tif ( delta > 0 ) {\n\n\t\t\tscope.dollyOut();\n\n\t\t} else if ( delta < 0 ) {\n\n\t\t\tscope.dollyIn();\n\n\t\t}\n\n\t\tscope.update();\n\t\tscope.dispatchEvent( startEvent );\n\t\tscope.dispatchEvent( endEvent );\n\n\t}\n\n\tfunction onKeyDown( event ) {\n\n\t\tif ( scope.enabled === false || scope.noKeys === true || scope.noPan === true ) return;\n\n\t\tswitch ( event.keyCode ) {\n\n\t\t\tcase scope.keys.UP:\n\t\t\t\tscope.pan( 0, scope.keyPanSpeed );\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase scope.keys.BOTTOM:\n\t\t\t\tscope.pan( 0, - scope.keyPanSpeed );\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase scope.keys.LEFT:\n\t\t\t\tscope.pan( scope.keyPanSpeed, 0 );\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase scope.keys.RIGHT:\n\t\t\t\tscope.pan( - scope.keyPanSpeed, 0 );\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tfunction touchstart( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tswitch ( event.touches.length ) {\n\n\t\t\tcase 1:\t// one-fingered touch: rotate\n\n\t\t\t\tif ( scope.noRotate === true ) return;\n\n\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\n\t\t\t\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\t// two-fingered touch: dolly\n\n\t\t\t\tif ( scope.noZoom === true ) return;\n\n\t\t\t\tstate = STATE.TOUCH_DOLLY;\n\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\t\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\t\t\t\tdollyStart.set( 0, distance );\n\t\t\t\tbreak;\n\n\t\t\tcase 3: // three-fingered touch: pan\n\n\t\t\t\tif ( scope.noPan === true ) return;\n\n\t\t\t\tstate = STATE.TOUCH_PAN;\n\n\t\t\t\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tif ( state !== STATE.NONE ) scope.dispatchEvent( startEvent );\n\n\t}\n\n\tfunction touchmove( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\tswitch ( event.touches.length ) {\n\n\t\t\tcase 1: // one-fingered touch: rotate\n\n\t\t\t\tif ( scope.noRotate === true ) return;\n\t\t\t\tif ( state !== STATE.TOUCH_ROTATE ) return;\n\n\t\t\t\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\n\t\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\t\tscope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\t\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\t\tscope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\n\t\t\t\trotateStart.copy( rotateEnd );\n\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase 2: // two-fingered touch: dolly\n\n\t\t\t\tif ( scope.noZoom === true ) return;\n\t\t\t\tif ( state !== STATE.TOUCH_DOLLY ) return;\n\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\t\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\t\tdollyEnd.set( 0, distance );\n\t\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\t\tscope.dollyOut();\n\n\t\t\t\t} else if ( dollyDelta.y < 0 ) {\n\n\t\t\t\t\tscope.dollyIn();\n\n\t\t\t\t}\n\n\t\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase 3: // three-fingered touch: pan\n\n\t\t\t\tif ( scope.noPan === true ) return;\n\t\t\t\tif ( state !== STATE.TOUCH_PAN ) return;\n\n\t\t\t\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\tpanDelta.subVectors( panEnd, panStart );\n\n\t\t\t\tscope.pan( panDelta.x, panDelta.y );\n\n\t\t\t\tpanStart.copy( panEnd );\n\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t}\n\n\tfunction touchend( /* event */ ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tscope.dispatchEvent( endEvent );\n\t\tstate = STATE.NONE;\n\n\t}\n\n\tthis.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );\n\tthis.domElement.addEventListener( 'mousedown', onMouseDown, false );\n\tthis.domElement.addEventListener( 'mousewheel', onMouseWheel, false );\n\tthis.domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox\n\n\tthis.domElement.addEventListener( 'touchstart', touchstart, false );\n\tthis.domElement.addEventListener( 'touchend', touchend, false );\n\tthis.domElement.addEventListener( 'touchmove', touchmove, false );\n\n\twindow.addEventListener( 'keydown', onKeyDown, false );\n\n\t// force an update at start\n\tthis.update();\n\n};\n\nTHREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );\nTHREE.OrbitControls.prototype.constructor = THREE.OrbitControls;"],"names":["THREE","OrbitControls","object","domElement","undefined","document","enabled","target","Vector3","center","noZoom","zoomSpeed","minDistance","maxDistance","Infinity","minZoom","maxZoom","noRotate","rotateSpeed","noPan","keyPanSpeed","autoRotate","autoRotateSpeed","minPolarAngle","maxPolarAngle","Math","PI","minAzimuthAngle","maxAzimuthAngle","noKeys","keys","LEFT","UP","RIGHT","BOTTOM","mouseButtons","ORBIT","MOUSE","ZOOM","MIDDLE","PAN","theta","phi","scope","rotateStart","Vector2","rotateEnd","rotateDelta","panStart","panEnd","panDelta","panOffset","offset","dollyStart","dollyEnd","dollyDelta","phiDelta","thetaDelta","scale","pan","lastPosition","lastQuaternion","Quaternion","STATE","NONE","ROTATE","DOLLY","TOUCH_ROTATE","TOUCH_DOLLY","TOUCH_PAN","state","target0","clone","position0","position","zoom0","zoom","quat","setFromUnitVectors","up","quatInverse","inverse","changeEvent","type","startEvent","endEvent","getAutoRotationAngle","getZoomScale","pow","onMouseMove","event","preventDefault","element","body","set","clientX","clientY","subVectors","rotateLeft","x","clientWidth","rotateUp","y","clientHeight","copy","dollyIn","dollyOut","update","onMouseUp","removeEventListener","dispatchEvent","onMouseWheel","stopPropagation","delta","wheelDelta","detail","angle","panLeft","distance","te","matrix","elements","multiplyScalar","add","panUp","deltaX","deltaY","PerspectiveCamera","targetDistance","sub","length","tan","fov","OrthographicCamera","right","left","top","bottom","console","warn","dollyScale","max","min","updateProjectionMatrix","applyQuaternion","atan2","z","sqrt","radius","sin","cos","lookAt","distanceToSquared","dot","quaternion","reset","getPolarAngle","getAzimuthalAngle","addEventListener","button","touches","pageX","pageY","dx","dy","window","keyCode","prototype","Object","create","EventDispatcher","constructor"],"version":3,"file":"index.98dba674.js.map"}