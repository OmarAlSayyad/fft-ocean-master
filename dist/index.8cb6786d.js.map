{"mappings":"AAAA;;CAEC,GAED,MAAM,WAAW,CAAC,0BAA0B,GAAG;IAE7C;IACA;IACA;IACA;IAEA;IAEA;IACA;IACC,yGAAyG;IACtG,yFAAyF;IAC7F;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;IACC,2DAA2D;IAC5D;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;IACC,kBAAkB;IAClB,sCAAsC;IACvC;IACA;IAEA;IACA;IACC,sDAAsD;IACtD,4BAA4B;IAC5B,4BAA4B;IAC5B,4BAA4B;IAC5B,4BAA4B;IAC7B;IACA;IAEC,kCAAkC;IACnC;IACA;IAEA;IACA;IACC,2EAA2E;IAC5E;IACA;IAEA;IACA;IACC,kEAAkE;IACnE;IACA;IACA;IAEC,mEAAmE;IACpE;IACA;IAEC,qDAAqD;IACtD;IAEC,uCAAuC;IACxC;IAEA;IAEA;IACA;IACA;IAEA;IACA;CAED,CAAC,IAAI,CAAC;AAEP,MAAM,WAAW,CAAC,qBAAqB,GAAG;IACzC;CACA,CAAC,IAAI,CAAC;AAEP,MAAM,WAAW,CAAC,4BAA4B,GAAG;IAC/C;CACD,CAAC,IAAI,CAAC","sources":["js/shaders/ScreenSpaceShader.js"],"sourcesContent":["/**\n * @author jbouny / https://github.com/fft-ocean\n */\n \nTHREE.ShaderChunk[\"screenplane_pars_vertex\"] = [\n\t\t\n\t\t'const float infinite = 150000.0;',\n\t\t'const float screenScale = 1.2;',\n\t\t'const vec3 groundNormal = vec3( 0.0, 1.0, 0.0 );',\n\t\t'const float groundHeight = 0.0;',\n\t\t\n\t\t'varying vec3 vCamPosition;',\n\t\t\n\t\t'vec3 interceptPlane( in vec3 source, in vec3 dir, in vec3 normal, float height )',\n\t\t'{',\n\t\t\t// Compute the distance between the source and the surface, following a ray, then return the intersection\n      // http://www.cs.rpi.edu/~cutler/classes/advancedgraphics/S09/lectures/11_ray_tracing.pdf\n\t\t'\tfloat distance = ( - height - dot( normal, source ) ) / dot( normal, dir );',\n\t\t'\tif( distance < 0.0 )',\n\t\t'\t\treturn source + dir * distance;',\n\t\t'\telse ',\n\t\t'\t\treturn - ( vec3( source.x, height, source.z ) + vec3( dir.x, height, dir.z ) * infinite );',\n\t\t'}',\n\t\t\n\t\t'mat3 getRotation()',\n\t\t'{',\n\t\t\t// Extract the 3x3 rotation matrix from the 4x4 view matrix\n\t\t'\treturn mat3( ',\n\t\t'\t\tviewMatrix[0].xyz,',\n\t\t'\t\tviewMatrix[1].xyz,',\n\t\t'\t\tviewMatrix[2].xyz',\n\t\t'\t);',\n\t\t'}',\n\t\t\n\t\t'vec3 getCameraPos( in mat3 rotation )',\n\t\t'{',\n\t\t\t// Xc = R * Xw + t\n\t\t\t// c = - R.t() * t <=> c = - t.t() * R\n\t\t'\treturn - viewMatrix[3].xyz * rotation;',\n\t\t'}',\n\n\t\t'vec2 getImagePlan()',\n\t\t'{',\n\t\t\t// Extracting aspect and focal from projection matrix:\n\t\t\t// P = | e   0       0   0 |\n\t\t\t//     | 0   e/(h/w) 0   0 |\n\t\t\t//     | 0   0       .   . |\n\t\t\t//     | 0   0       -1  0 |\n\t\t'\tfloat focal = projectionMatrix[0].x;',\n\t\t'\tfloat aspect = projectionMatrix[1].y;',\n\t\t\t\n\t\t\t// Fix coordinate aspect and scale\n\t\t'\treturn vec2( ( uv.x - 0.5 ) * screenScale * aspect, ( uv.y - 0.5 ) * screenScale * focal );',\n\t\t'}',\n\t\t\n\t\t'vec3 getCamRay( in mat3 rotation, in vec2 screenUV )',\n\t\t'{',\n\t\t\t// Compute camera ray then rotate it in order to get it in world coordinate\n\t\t'\treturn vec3( screenUV.x, screenUV.y, projectionMatrix[0].x ) * rotation;',\n\t\t'}',\n\t\t\n\t\t'vec3 computeProjectedPosition()',\n\t\t'{',\n\t\t\t// Extract camera position and rotation from the model view matrix\n\t\t'\tmat3 cameraRotation = getRotation();',\n\t\t'\tvec3 camPosition = getCameraPos( cameraRotation );',\n\t\t'\tvCamPosition = camPosition;',\n\t\t\n\t\t\t// Return the intersection between the camera ray and a given plane\n\t\t'\tif( camPosition.y < groundHeight )',\n\t\t'\t\treturn vec3( 0.0, 0.0, 0.0 );',\n\t\t\n\t\t\t// Extract coordinate of the vertex on the image plan\n\t\t'\tvec2 screenUV = getImagePlan() ;',\n\t\t\t\n\t\t\t// Compute the ray from camera to world\n\t\t'\tvec3 ray = getCamRay( cameraRotation, screenUV );',\n\t\t\t\n\t\t'\tvec3 finalPos = interceptPlane( camPosition, ray, groundNormal, groundHeight );',\n\t\t\n\t\t'\tfloat distance = length( finalPos );',\n\t\t'\tif( distance > infinite )',\n\t\t'\t\tfinalPos *= infinite / distance;',\n\t\t\n\t\t'\treturn finalPos;',\n\t\t'}'\n\t\n].join('\\n');\n\nTHREE.ShaderChunk[\"screenplane_vertex\"] = [\n\t'vec4 screenPlaneWorldPosition = vec4( computeProjectedPosition(), 1.0 );',\n].join('\\n');\n\nTHREE.ShaderChunk[\"screenplane_pars_fragment\"] = [\n\t\t'varying vec3 vCamPosition;'\n].join('\\n');"],"names":[],"version":3,"file":"index.8cb6786d.js.map","sourceRoot":"/__parcel_source_root/"}